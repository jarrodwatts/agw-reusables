{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "use-optimistic-write-contract",
  "type": "registry:hook",
  "title": "useOptimisticWriteContract",
  "description": "An experimental hook for optimistic transaction execution using Abstract's unstable_sendRawTransactionWithDetailedOutput endpoint to get instant transaction feedback",
  "dependencies": [
    "wagmi",
    "viem",
    "@tanstack/react-query"
  ],
  "registryDependencies": [],
  "files": [
    {
      "path": "registry/new-york/blocks/use-optimistic-write-contract/hooks/use-optimistic-write-contract.ts",
      "content": "\"use client\"\n\nimport { useState, useCallback } from \"react\"\nimport { useAccount, useWalletClient } from \"wagmi\"\nimport { type WriteContractParameters } from \"wagmi/actions\"\nimport { encodeFunctionData } from \"viem\"\nimport type { Abi, ContractFunctionName } from \"viem\"\nimport type { OptimisticTransactionResponse } from \"../lib/types\"\nimport { sendRawTransactionWithDetailedOutput } from \"../lib/abstract-api\"\n\ntype OptimisticWriteConfig<\n  TConfig extends WriteContractParameters = WriteContractParameters\n> = TConfig & {\n  onSuccess?: (data: OptimisticTransactionResponse, startTime: number) => void\n  onError?: (error: Error) => void\n}\n\nexport function useOptimisticWriteContract() {\n  const { address } = useAccount()\n  const { data: walletClient } = useWalletClient()\n\n  const [isPending, setIsPending] = useState(false)\n  const [data, setData] = useState<OptimisticTransactionResponse>()\n  const [error, setError] = useState<Error>()\n\n  const writeContract = useCallback(async <TConfig extends WriteContractParameters>(\n    config: OptimisticWriteConfig<TConfig>\n  ) => {\n    if (!address || !walletClient) throw new Error(\"Wallet not connected\")\n\n    setIsPending(true)\n    setError(undefined)\n    setData(undefined)\n\n    try {\n      // Encode function data and prepare transaction request\n      const { onSuccess, onError, ...contractParams } = config\n      const txData = encodeFunctionData({\n        abi: contractParams.abi as Abi,\n        functionName: contractParams.functionName as ContractFunctionName<Abi>,\n        args: contractParams.args as unknown[] | undefined,\n      })\n\n      const request = await walletClient.prepareTransactionRequest({\n        to: contractParams.address,\n        data: txData,\n      })\n\n      // Sign transaction (this triggers wallet approval popup)\n      const signedTransaction = await walletClient.signTransaction(request)\n\n      // Start timing AFTER user approval\n      const startTime = Date.now()\n\n      // Send to Abstract's optimistic endpoint\n      const result = await sendRawTransactionWithDetailedOutput(signedTransaction)\n\n      setData(result)\n      config.onSuccess?.(result, startTime)\n      return result\n    } catch (err) {\n      const error = err instanceof Error ? err : new Error('Unknown error')\n      console.error(`‚ùå [Optimistic] Error:`, error.message)\n      setError(error)\n      config.onError?.(error)\n      throw error\n    } finally {\n      setIsPending(false)\n    }\n  }, [address, walletClient])\n\n  const writeContractSync = useCallback(<TConfig extends WriteContractParameters>(\n    config: OptimisticWriteConfig<TConfig>\n  ) => {\n    writeContract(config).catch(() => {\n      // Errors already handled by onError callback and internal error state\n    })\n  }, [writeContract])\n\n  const reset = useCallback(() => {\n    setData(undefined)\n    setError(undefined)\n    setIsPending(false)\n  }, [])\n\n  return {\n    writeContract: writeContractSync,\n    writeContractAsync: writeContract,\n    isPending,\n    isLoading: isPending, // For backward compatibility\n    data,\n    error,\n    isSuccess: !!data,\n    isError: !!error,\n    reset,\n  }\n}",
      "type": "registry:hook"
    },
    {
      "path": "registry/new-york/blocks/use-optimistic-write-contract/lib/types.ts",
      "content": "export interface OptimisticTransactionResponse {\n  transactionHash: `0x${string}`\n  storageLogs: StorageLog[]\n  events: OptimisticEvent[]\n}\n\nexport interface StorageLog {\n  address: `0x${string}`\n  key: `0x${string}`\n  writtenValue: `0x${string}`\n}\n\nexport interface OptimisticEvent {\n  address: `0x${string}`\n  topics: `0x${string}`[]\n  data: `0x${string}`\n  blockHash: null\n  blockNumber: null\n  l1BatchNumber: `0x${string}`\n  transactionHash: `0x${string}`\n  transactionIndex: `0x${string}`\n  logIndex: null\n  transactionLogIndex: null\n  logType: null\n  removed: false\n}\n\nexport interface AbstractRpcRequest {\n  jsonrpc: \"2.0\"\n  id: number\n  method: \"unstable_sendRawTransactionWithDetailedOutput\"\n  params: [string] // signed transaction hex\n}\n\nexport interface AbstractRpcResponse {\n  jsonrpc: \"2.0\"\n  id: number\n  result?: OptimisticTransactionResponse\n  error?: {\n    code: number\n    message: string\n  }\n}\n\n",
      "type": "registry:lib"
    },
    {
      "path": "registry/new-york/blocks/use-optimistic-write-contract/lib/abstract-api.ts",
      "content": "import type { \n  AbstractRpcRequest, \n  AbstractRpcResponse, \n  OptimisticTransactionResponse \n} from \"./types\"\n\nconst ABSTRACT_API_URL = \"https://api.testnet.abs.xyz\"\n\nexport async function sendRawTransactionWithDetailedOutput(\n  signedTransaction: `0x${string}`\n): Promise<OptimisticTransactionResponse> {\n  const request: AbstractRpcRequest = {\n    jsonrpc: \"2.0\",\n    id: 1,\n    method: \"unstable_sendRawTransactionWithDetailedOutput\",\n    params: [signedTransaction],\n  }\n\n  const response = await fetch(ABSTRACT_API_URL, {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n    body: JSON.stringify(request),\n  })\n\n  if (!response.ok) {\n    throw new Error(`HTTP error! status: ${response.status}`)\n  }\n\n  const data: AbstractRpcResponse = await response.json()\n\n  if (data.error) {\n    // Parse common error messages to make them more user-friendly\n    const errorMessage = data.error.message || \"\"\n    \n    let humanReadableError = \"\"\n\n    if (errorMessage.includes(\"insufficient funds\")) {\n      humanReadableError = \"ETH balance too low.\"\n    } else if (errorMessage.includes(\"known transaction\")) {\n      humanReadableError = \"Nonce issue. Please refresh.\"\n    } else if (errorMessage.includes(\"nonce too low\")) {\n      humanReadableError = \"Nonce issue. Please refresh.\"\n    } else if (errorMessage.includes(\"gas required exceeds allowance\")) {\n      humanReadableError = \"Gas issue. Please refresh.\"\n    } else if (errorMessage.includes(\"replacement transaction underpriced\")) {\n      humanReadableError = \"Gas issue. Please refresh.\"\n    } else if (errorMessage.includes(\"max fee per gas less than block base fee\")) {\n      humanReadableError = \"Transaction fee too low for current network conditions\"\n    } else {\n      // For unknown errors, use a generic message with the error code\n      humanReadableError = `Transaction failed (Error: ${errorMessage})`\n    }\n\n    throw new Error(humanReadableError)\n  }\n\n  if (!data.result || !data.result.transactionHash) {\n    throw new Error(\n      \"Transaction submission did not return a transaction hash. Please try again.\"\n    )\n  }\n\n  return data.result\n}",
      "type": "registry:lib"
    }
  ]
}