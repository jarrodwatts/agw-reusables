{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "abstract-contracts",
  "type": "registry:lib",
  "title": "Abstract Contracts",
  "description": "Configuration for common Abstract network contract addresses and ABIs for tokens and DEX infrastructure",
  "dependencies": [],
  "registryDependencies": [],
  "files": [
    {
      "path": "registry/new-york/blocks/abstract-contracts/abstract-contracts.tsx",
      "content": "// Re-export the contracts configuration and utilities\nexport { ABSTRACT_CONTRACTS } from \"./lib/contracts\"\nexport { getContract, getContractAddress, ABSTRACT_NETWORKS } from \"./lib/utils\"\nexport type { NetworkId, ContractInfo, ContractsConfig } from \"./lib/types\"\n\n// Export individual ABIs\nexport {\n  WETH9_ABI,\n  USDC_ABI,\n  USDT_ABI,\n  UNISWAP_V2_FACTORY_ABI,\n  UNISWAP_V2_ROUTER_ABI,\n  UNISWAP_V3_FACTORY_ABI,\n  QUOTER_V2_ABI,\n  SWAP_ROUTER_02_ABI\n} from \"./lib/contracts\"",
      "type": "registry:lib"
    },
    {
      "path": "registry/new-york/blocks/abstract-contracts/lib/types.ts",
      "content": "export interface ContractAddress {\n  mainnet?: string\n  testnet?: string\n}\n\nexport interface ContractInfo {\n  name: string\n  description: string\n  addresses: ContractAddress\n  abi?: any[] // ABI will be populated manually\n  category: 'token' | 'dex' | 'utility'\n}\n\nexport interface ContractsConfig {\n  tokens: Record<string, ContractInfo>\n  dex: Record<string, ContractInfo>\n}\n\nexport type NetworkId = 2741 | 11124 // Abstract mainnet | Abstract testnet\n\nexport interface UseContractAddressOptions {\n  chainId?: NetworkId\n  throwOnMissing?: boolean\n}",
      "type": "registry:lib"
    },
    {
      "path": "registry/new-york/blocks/abstract-contracts/lib/contracts.ts",
      "content": "import type { ContractsConfig } from \"./types\"\n\n// TODO: Add ABIs manually for each contract below\n// Each contract has a placeholder for its ABI that can be populated\n\n// WETH9 ABI - TODO: Add ABI here\nconst WETH9_ABI = [\n  // TODO: Add WETH9 ABI array here\n  // Standard ERC20 + deposit/withdraw functions\n]\n\n// USDC ABI - TODO: Add ABI here  \nconst USDC_ABI = [\n  // TODO: Add USDC ABI array here\n  // Standard ERC20 functions\n]\n\n// USDT ABI - TODO: Add ABI here\nconst USDT_ABI = [\n  // TODO: Add USDT ABI array here\n  // Standard ERC20 functions (note: USDT has some non-standard behaviors)\n]\n\n// UniswapV2Factory ABI - TODO: Add ABI here\nconst UNISWAP_V2_FACTORY_ABI = [\n  // TODO: Add UniswapV2Factory ABI array here\n  // createPair, getPair, allPairs, etc.\n]\n\n// UniswapV2Router02 ABI - TODO: Add ABI here\nconst UNISWAP_V2_ROUTER_ABI = [\n  // TODO: Add UniswapV2Router02 ABI array here\n  // swapExactTokensForTokens, addLiquidity, removeLiquidity, etc.\n]\n\n// UniswapV3Factory ABI - TODO: Add ABI here\nconst UNISWAP_V3_FACTORY_ABI = [\n  // TODO: Add UniswapV3Factory ABI array here\n  // createPool, getPool, etc.\n]\n\n// QuoterV2 ABI - TODO: Add ABI here\nconst QUOTER_V2_ABI = [\n  // TODO: Add QuoterV2 ABI array here\n  // quoteExactInputSingle, quoteExactInput, etc.\n]\n\n// SwapRouter02 ABI - TODO: Add ABI here\nconst SWAP_ROUTER_02_ABI = [\n  // TODO: Add SwapRouter02 ABI array here\n  // exactInputSingle, exactInput, etc.\n]\n\nexport const ABSTRACT_CONTRACTS: ContractsConfig = {\n  tokens: {\n    weth: {\n      name: \"Wrapped Ether\",\n      description: \"WETH9 - Wrapped Ether contract for Abstract\",\n      addresses: {\n        mainnet: \"0x3439153EB7AF838Ad19d56E1571FBD09333C2809\",\n        testnet: \"0x9EDCde0257F2386Ce177C3a7FCdd97787F0D841d\"\n      },\n      abi: WETH9_ABI,\n      category: \"token\"\n    },\n    usdc: {\n      name: \"USD Coin\", \n      description: \"USDC - Circle's stablecoin on Abstract\",\n      addresses: {\n        mainnet: \"0x84A71ccD554Cc1b02749b35d22F684CC8ec987e1\",\n        testnet: \"0xe4C7fBB0a626ed208021ccabA6Be1566905E2dFc\"\n      },\n      abi: USDC_ABI,\n      category: \"token\"\n    },\n    usdt: {\n      name: \"Tether USD\",\n      description: \"USDT - Tether's stablecoin on Abstract\",\n      addresses: {\n        mainnet: \"0x0709F39376dEEe2A2dfC94A58EdEb2Eb9DF012bD\"\n        // Note: No testnet address available\n      },\n      abi: USDT_ABI,\n      category: \"token\"\n    }\n  },\n  dex: {\n    uniswapV2Factory: {\n      name: \"Uniswap V2 Factory\",\n      description: \"Factory contract for creating Uniswap V2 pairs\",\n      addresses: {\n        mainnet: \"0x566d7510dEE58360a64C9827257cF6D0Dc43985E\",\n        testnet: \"0x566d7510dEE58360a64C9827257cF6D0Dc43985E\"\n      },\n      abi: UNISWAP_V2_FACTORY_ABI,\n      category: \"dex\"\n    },\n    uniswapV2Router: {\n      name: \"Uniswap V2 Router02\",\n      description: \"Router contract for Uniswap V2 swaps and liquidity\",\n      addresses: {\n        mainnet: \"0xad1eCa41E6F772bE3cb5A48A6141f9bcc1AF9F7c\",\n        testnet: \"0x96ff7D9dbf52FdcAe79157d3b249282c7FABd409\"\n      },\n      abi: UNISWAP_V2_ROUTER_ABI,\n      category: \"dex\"\n    },\n    uniswapV3Factory: {\n      name: \"Uniswap V3 Factory\", \n      description: \"Factory contract for creating Uniswap V3 pools\",\n      addresses: {\n        mainnet: \"0xA1160e73B63F322ae88cC2d8E700833e71D0b2a1\",\n        testnet: \"0x2E17FF9b877661bDFEF8879a4B31665157a960F0\"\n      },\n      abi: UNISWAP_V3_FACTORY_ABI,\n      category: \"dex\"\n    },\n    quoterV2: {\n      name: \"Quoter V2\",\n      description: \"Uniswap V3 quoter for getting swap quotes\",\n      addresses: {\n        mainnet: \"0x728BD3eC25D5EDBafebB84F3d67367Cd9EBC7693\",\n        testnet: \"0xdE41045eb15C8352413199f35d6d1A32803DaaE2\"\n      },\n      abi: QUOTER_V2_ABI,\n      category: \"dex\"\n    },\n    swapRouter02: {\n      name: \"Swap Router 02\",\n      description: \"Uniswap V3 router for executing swaps\",\n      addresses: {\n        mainnet: \"0x7712FA47387542819d4E35A23f8116C90C18767C\", \n        testnet: \"0xb9D4347d129a83cBC40499Cd4fF223dE172a70dF\"\n      },\n      abi: SWAP_ROUTER_02_ABI,\n      category: \"dex\"\n    }\n  }\n}\n\n// Export individual ABIs for easy importing\nexport {\n  WETH9_ABI,\n  USDC_ABI, \n  USDT_ABI,\n  UNISWAP_V2_FACTORY_ABI,\n  UNISWAP_V2_ROUTER_ABI,\n  UNISWAP_V3_FACTORY_ABI,\n  QUOTER_V2_ABI,\n  SWAP_ROUTER_02_ABI\n}",
      "type": "registry:lib"
    },
    {
      "path": "registry/new-york/blocks/abstract-contracts/lib/utils.ts",
      "content": "import type { NetworkId, ContractAddress } from \"./types\"\nimport { ABSTRACT_CONTRACTS } from \"./contracts\"\n\nexport const ABSTRACT_NETWORKS = {\n  MAINNET: 2741 as const,\n  TESTNET: 11124 as const\n} as const\n\nexport function getNetworkName(chainId: NetworkId): string {\n  switch (chainId) {\n    case ABSTRACT_NETWORKS.MAINNET:\n      return \"Abstract Mainnet\"\n    case ABSTRACT_NETWORKS.TESTNET:  \n      return \"Abstract Testnet\"\n    default:\n      return \"Unknown Network\"\n  }\n}\n\nexport function isAbstractNetwork(chainId: number): chainId is NetworkId {\n  return chainId === ABSTRACT_NETWORKS.MAINNET || chainId === ABSTRACT_NETWORKS.TESTNET\n}\n\nexport function getContractAddress(\n  addresses: ContractAddress, \n  chainId: NetworkId,\n  throwOnMissing = false\n): string | undefined {\n  const address = chainId === ABSTRACT_NETWORKS.MAINNET \n    ? addresses.mainnet \n    : addresses.testnet\n\n  if (!address && throwOnMissing) {\n    const networkName = getNetworkName(chainId)\n    throw new Error(`Contract address not available on ${networkName}`)\n  }\n\n  return address\n}\n\nexport function getContract(contractKey: string, chainId: NetworkId, throwOnMissing = false) {\n  // Find contract in both tokens and dex categories\n  const contract = ABSTRACT_CONTRACTS.tokens[contractKey] || ABSTRACT_CONTRACTS.dex[contractKey]\n  \n  if (!contract) {\n    if (throwOnMissing) {\n      throw new Error(`Contract \"${contractKey}\" not found`)\n    }\n    return undefined\n  }\n\n  if (!isAbstractNetwork(chainId)) {\n    if (throwOnMissing) {\n      throw new Error(`Unsupported chain ID: ${chainId}. Only Abstract networks are supported.`)\n    }\n    return undefined\n  }\n\n  const address = getContractAddress(contract.addresses, chainId, throwOnMissing)\n  \n  return {\n    ...contract,\n    address\n  }\n}",
      "type": "registry:lib"
    }
  ]
}