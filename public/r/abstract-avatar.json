{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "abstract-avatar",
  "type": "registry:component",
  "title": "Abstract Avatar",
  "description": "An avatar component that displays user profile pictures from Abstract Portal with tier-based styling and loading states",
  "dependencies": [
    "@tanstack/react-query",
    "wagmi",
    "viem"
  ],
  "registryDependencies": [
    "avatar",
    "tooltip",
    "skeleton"
  ],
  "files": [
    {
      "path": "registry/new-york/blocks/abstract-avatar/abstract-avatar.tsx",
      "content": "\"use client\";\n\nimport React from \"react\";\nimport { Avatar, AvatarFallback, AvatarImage } from \"@/registry/new-york/ui/avatar\";\nimport {\n  Tooltip,\n  TooltipContent,\n  TooltipTrigger,\n} from \"@/registry/new-york/ui/tooltip\";\nimport { Skeleton } from \"@/registry/new-york/ui/skeleton\";\nimport { useAbstractProfileByAddress } from \"@/registry/new-york/blocks/abstract-avatar/hooks/use-abstract-profile\";\nimport { getTierColor } from \"@/registry/new-york/blocks/abstract-avatar/lib/tier-colors\";\nimport { getDisplayName } from \"@/registry/new-york/blocks/abstract-avatar/lib/address-utils\";\nimport { useAccount } from \"wagmi\";\n\ninterface AbstractAvatarProps {\n  address?: string; // Optional - defaults to connected wallet\n  fallback?: string; // Optional - defaults to first 2 chars of address\n  shineColor?: string; // Optional now, will use tier color if not provided\n  size?: \"sm\" | \"md\" | \"lg\";\n  showTooltip?: boolean; // Optional tooltip\n}\n\n/**\n * Abstract Avatar Component\n * \n * A comprehensive avatar component that integrates with the Abstract Portal API to display:\n * - User profile pictures from Abstract Portal\n * - Tier-based colored borders (Bronze, Silver, Gold, Platinum, Diamond)\n * - Loading states with skeleton placeholders\n * - Fallback support for missing profile data\n * - Responsive size variants\n * - Optional tooltips with display names\n * \n * @param address - Optional wallet address to fetch profile for (defaults to connected wallet)\n * @param fallback - Optional fallback text to display if image fails to load (defaults to first 2 chars of address)\n * @param shineColor - Optional custom border color (defaults to tier color)\n * @param size - Avatar size variant (sm, md, lg)\n * @param showTooltip - Whether to show tooltip on hover\n */\nexport function AbstractAvatar({\n  address: providedAddress,\n  fallback: providedFallback,\n  shineColor,\n  size = \"md\",\n  showTooltip = true,\n}: AbstractAvatarProps) {\n  const { address: connectedAddress } = useAccount();\n  \n  // Use provided address or fall back to connected wallet address\n  const address = providedAddress || connectedAddress;\n  \n  // Generate fallback from address if not provided\n  const fallback = providedFallback || (address ? address.slice(2, 4).toUpperCase() : \"??\");\n  \n  const sizeClasses = {\n    sm: \"h-8 w-8\",\n    md: \"h-10 w-10\",\n    lg: \"h-12 w-12\",\n  };\n\n  const { data: profile, isLoading } = useAbstractProfileByAddress(address);\n  \n  // If no address available, show a skeleton loading state\n  if (!address) {\n    return (\n      <div \n        className={`relative rounded-full ${sizeClasses[size]}`} \n        style={{ border: `2px solid #C0C0C0` }}\n      >\n        <div className=\"absolute inset-0 rounded-full overflow-hidden\">\n          <Skeleton \n            className={`w-full h-full rounded-full`} \n          />\n        </div>\n      </div>\n    );\n  }\n\n  const avatarSrc =\n    profile?.user?.overrideProfilePictureUrl ||\n    \"https://abstract-assets.abs.xyz/avatars/1-1-1.png\";\n\n  const displayName = getDisplayName(profile?.user?.name || \"\", address);\n\n  // Use tier-based color if shineColor not provided\n  const tierColor = profile?.user?.tier ? getTierColor(profile.user.tier) : getTierColor(2);\n  const finalBorderColor = shineColor || tierColor;\n\n  if (isLoading) {\n    return (\n      <div \n        className={`relative rounded-full ${sizeClasses[size]}`} \n        style={{ border: `2px solid ${finalBorderColor}` }}\n      >\n        <div className=\"absolute inset-0 rounded-full overflow-hidden\">\n          <Skeleton \n            className={`w-full h-full rounded-full transition-transform duration-200 hover:scale-110`} \n          />\n        </div>\n      </div>\n    );\n  }\n\n  const avatarElement = (\n    <div \n      className={`relative rounded-full ${sizeClasses[size]}`} \n      style={{ border: `2px solid ${finalBorderColor}` }}\n    >\n      <div className=\"absolute inset-0 rounded-full overflow-hidden\">\n        <Avatar \n          className={`w-full h-full transition-transform duration-200 hover:scale-110`}\n        >\n          <AvatarImage \n            src={avatarSrc} \n            alt={`${displayName} avatar`}\n            className=\"object-cover\" \n          />\n          <AvatarFallback>{fallback}</AvatarFallback>\n        </Avatar>\n      </div>\n    </div>\n  );\n\n  if (!showTooltip) {\n    return avatarElement;\n  }\n\n  return (\n    <Tooltip>\n      <TooltipTrigger asChild>\n        {avatarElement}\n      </TooltipTrigger>\n      <TooltipContent>\n        <p>{displayName}</p>\n      </TooltipContent>\n    </Tooltip>\n  );\n}",
      "type": "registry:component"
    },
    {
      "path": "registry/new-york/blocks/abstract-avatar/abstract-avatar-demo.tsx",
      "content": "\"use client\";\n\nimport { AbstractAvatar } from \"./abstract-avatar\";\n\nexport function AbstractAvatarDemo() {\n  return (\n    <div className=\"flex flex-col gap-6\">\n      {/* No address - shows skeleton */}\n      <div className=\"flex flex-col gap-2\">\n        <span className=\"text-sm text-muted-foreground\">Connected Wallet Profile</span>\n        <div className=\"flex items-center gap-4\">\n          <AbstractAvatar size=\"sm\" />\n          <AbstractAvatar size=\"md\" />\n          <AbstractAvatar size=\"lg\" />\n        </div>\n      </div>\n\n      {/* With sample addresses */}\n      <div className=\"flex flex-col gap-2\">\n        <span className=\"text-sm text-muted-foreground\">Example Profiles</span>\n        <div className=\"flex items-center gap-4\">\n          <AbstractAvatar\n            address=\"0x06639F064b82595F3BE7621F607F8e8726852fCf\"\n            size=\"sm\"\n          />\n          <AbstractAvatar\n            address=\"0x1C67724aCc76821C8aD1f1F87BA2751631BAbD0c\"\n            size=\"md\"\n          />\n          <AbstractAvatar\n            address=\"0x1BdE3D2861Cb5216Eb6Ec559aFdE7d44f385D4f6\"\n            size=\"lg\"\n          />\n        </div>\n      </div>\n    </div>\n  );\n}",
      "type": "registry:component"
    },
    {
      "path": "registry/new-york/blocks/abstract-avatar/hooks/use-abstract-profile.ts",
      "content": "\"use client\";\n\nimport { getUserProfile } from \"@/registry/new-york/blocks/abstract-avatar/lib/get-user-profile\";\nimport { useQuery } from \"@tanstack/react-query\";\nimport { useAccount } from \"wagmi\";\n\n/**\n * Query keys for Abstract profile queries\n */\nconst QUERY_KEYS = {\n  profile: \"abstract-profile\",\n} as const;\n\n/**\n * Hook to retrieve the Abstract Portal profile for the current connected account\n * @returns The profile data with loading and error states\n */\nexport function useAbstractProfile() {\n  const { address } = useAccount();\n\n  return useQuery({\n    queryKey: [QUERY_KEYS.profile, address],\n    queryFn: async () => {\n      if (!address) {\n        return null;\n      }\n      return await getUserProfile(address);\n    },\n    enabled: !!address,\n    staleTime: 1000 * 60 * 1, // 1 minute\n    refetchOnWindowFocus: false,\n  });\n}\n\n/**\n * Hook to retrieve the Abstract Portal profile for a specific address\n * @param address - The address to get the profile for\n * @returns The profile data with loading and error states\n */\nexport function useAbstractProfileByAddress(address: string | undefined) {\n  return useQuery({\n    queryKey: [QUERY_KEYS.profile, address],\n    queryFn: async () => {\n      if (!address) {\n        return null;\n      }\n      return await getUserProfile(address);\n    },\n    enabled: !!address,\n    staleTime: 1000 * 60 * 5, // 5 minutes (longer for other users)\n    refetchOnWindowFocus: false,\n    retry: (failureCount, error: Error & { status?: number }) => {\n      // Don't retry if it's a 404 (profile doesn't exist) or similar client errors\n      if (error?.status && error?.status >= 400 && error?.status < 500) {\n        return false;\n      }\n      // Retry up to 2 times for other errors\n      return failureCount < 2;\n    },\n    retryDelay: attemptIndex => Math.min(1000 * 2 ** attemptIndex, 30000),\n  });\n}",
      "type": "registry:hook"
    },
    {
      "path": "registry/new-york/blocks/abstract-avatar/lib/fetch-json.ts",
      "content": "/**\n * A utility function for making JSON API requests with proper error handling\n */\nexport async function fetchJson<T>(\n  url: string,\n  options?: RequestInit\n): Promise<T> {\n  const response = await fetch(url, {\n    headers: {\n      'Content-Type': 'application/json',\n      ...options?.headers,\n    },\n    ...options,\n  });\n\n  if (!response.ok) {\n    const error = new Error(`HTTP error! status: ${response.status}`) as Error & { status?: number };\n    error.status = response.status;\n    throw error;\n  }\n\n  return response.json();\n}",
      "type": "registry:lib"
    },
    {
      "path": "registry/new-york/blocks/abstract-avatar/lib/tier-colors.ts",
      "content": "/**\n * Maps tier numbers to their corresponding colors\n * 1 = Bronze, 2 = Silver, 3 = Gold, 4 = Platinum, 5 = Diamond\n */\nexport const TIER_COLORS = {\n    1: \"#CD7F32\", // Bronze\n    2: \"#C0C0C0\", // Silver  \n    3: \"#FFD700\", // Gold\n    4: \"#E5E4E2\", // Platinum\n    5: \"#B9F2FF\", // Diamond\n} as const;\n\n/**\n * Gets the color for a given tier number\n * @param tier - The tier number (1-5)\n * @returns The hex color string for the tier\n */\nexport function getTierColor(tier: number): string {\n    // Default to silver if tier is invalid or not provided\n    if (!tier || tier < 1 || tier > 5) {\n        return TIER_COLORS[2]; // Silver as default\n    }\n\n    return TIER_COLORS[tier as keyof typeof TIER_COLORS];\n}\n\n/**\n * Gets the tier name from tier number\n * @param tier - The tier number (1-5)\n * @returns The tier name\n */\nexport function getTierName(tier: number): string {\n    const tierNames = {\n        1: \"Bronze\",\n        2: \"Silver\",\n        3: \"Gold\",\n        4: \"Platinum\",\n        5: \"Diamond\",\n    } as const;\n\n    if (!tier || tier < 1 || tier > 5) {\n        return \"Silver\"; // Default\n    }\n\n    return tierNames[tier as keyof typeof tierNames];\n}",
      "type": "registry:lib"
    },
    {
      "path": "registry/new-york/blocks/abstract-avatar/lib/address-utils.ts",
      "content": "import { isAddress } from 'viem';\n\n/**\n * Utility functions for formatting blockchain addresses\n */\n\n/**\n * Trims an Ethereum address to show only the first and last few characters\n * @param address - The full Ethereum address\n * @param startChars - Number of characters to show at the start (default: 6)\n * @param endChars - Number of characters to show at the end (default: 4)\n * @returns Trimmed address in format \"0x1234...5678\"\n */\nexport function trimAddress(\n    address: string,\n    startChars: number = 6,\n    endChars: number = 4\n): string {\n    if (!address) return '';\n    if (address.length <= startChars + endChars) return address;\n\n    return `${address.slice(0, startChars)}...${address.slice(-endChars)}`;\n}\n\n/**\n * Checks if a string is a valid Ethereum address and trims it if so\n * @param nameOrAddress - The string to check (could be username or address)\n * @param fallbackAddress - The actual user address to use if nameOrAddress is an address\n * @returns Trimmed address if nameOrAddress is an address, otherwise returns nameOrAddress\n */\nexport function getDisplayName(nameOrAddress: string, fallbackAddress?: string): string {\n    if (!nameOrAddress) return fallbackAddress ? trimAddress(fallbackAddress) : 'anon';\n\n    // If the name is actually an address, trim it\n    if (isAddress(nameOrAddress)) {\n        return trimAddress(nameOrAddress);\n    }\n\n    // Otherwise, it's a real username, return as-is\n    return nameOrAddress;\n}",
      "type": "registry:lib"
    },
    {
      "path": "registry/new-york/blocks/abstract-avatar/lib/get-user-profile.ts",
      "content": "import { fetchJson } from \"@/registry/new-york/blocks/abstract-avatar/lib/fetch-json\";\n\n/**\n * The profile information returned from the Abstract Portal API\n */\nexport type AbstractPortalProfile = {\n  user: {\n    id: string;\n    name: string;\n    description: string;\n    walletAddress: string;\n    avatar: {\n      assetType: string;\n      tier: number;\n      key: number;\n      season: number;\n    };\n    banner: {\n      assetType: string;\n      tier: number;\n      key: number;\n      season: number;\n    };\n    tier: number;\n    hasCompletedWelcomeTour: boolean;\n    hasStreamingAccess: boolean;\n    overrideProfilePictureUrl: string;\n    lastTierSeen: number;\n    metadata: {\n      lastTierSeen: number;\n      lastUpgradeSeen: number;\n      hasCompletedWelcomeTour: boolean;\n    };\n    badges: {\n      badge: {\n        id: number;\n        type: string;\n        name: string;\n        icon: string;\n        description: string;\n        requirement: string;\n        url?: string;\n        timeStart?: number;\n        timeEnd?: number;\n      };\n      claimed: boolean;\n    }[];\n    verification: string;\n  };\n};\n\n/**\n * Get the profile information of an Abstract Global Wallet given the wallet address\n * @param walletAddress - The wallet address to get the profile for\n * @returns The profile information\n */\nexport async function getUserProfile(walletAddress: string) {\n  return await fetchJson<AbstractPortalProfile>(\n    `/api/user-profile/${walletAddress}`\n  );\n}",
      "type": "registry:lib"
    },
    {
      "path": "app/api/user-profile/[address]/route.ts",
      "content": "import { NextRequest, NextResponse } from \"next/server\";\n\nconst ABSTRACT_PORTAL_API_URL = \"https://backend.portal.abs.xyz/api\";\n\nexport async function GET(\n  request: NextRequest,\n  { params }: { params: Promise<{ address: string }> }\n) {\n  try {\n    const { address } = await params;\n\n    // Validate the address parameter\n    if (!address) {\n      return NextResponse.json(\n        { error: \"Address parameter is required\" },\n        { status: 400 }\n      );\n    }\n\n    // Fetch user profile from Abstract Portal API\n    const response = await fetch(\n      `${ABSTRACT_PORTAL_API_URL}/user/address/${address}`,\n      {\n        method: \"GET\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n          \"User-Agent\": \"agw-reusables/1.0\",\n        },\n        // Add cache control\n        next: { revalidate: 300 }, // Cache for 5 minutes\n      }\n    );\n\n    // Handle non-200 responses\n    if (!response.ok) {\n      if (response.status === 404) {\n        return NextResponse.json(\n          { error: \"User profile not found\" },\n          { status: 404 }\n        );\n      }\n\n      return NextResponse.json(\n        { error: \"Failed to fetch user profile\" },\n        { status: response.status }\n      );\n    }\n\n    const profileData = await response.json();\n\n    // Return the profile data with appropriate headers\n    return NextResponse.json(profileData, {\n      headers: {\n        \"Cache-Control\": \"public, s-maxage=300, stale-while-revalidate=600\",\n      },\n    });\n  } catch (error) {\n    console.error(\"Error fetching user profile:\", error);\n    return NextResponse.json(\n      { error: \"Internal server error\" },\n      { status: 500 }\n    );\n  }\n}",
      "type": "registry:page",
      "target": "app/api/user-profile/[address]/route.ts"
    }
  ]
}