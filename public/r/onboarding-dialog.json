{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "onboarding-dialog",
  "type": "registry:component",
  "title": "Onboarding Dialog",
  "description": "A configurable multi-step onboarding dialog that guides users through AGW authentication (wallet connection, SIWE, session keys) with progress indication",
  "dependencies": [
    "@abstract-foundation/agw-react",
    "@abstract-foundation/agw-client",
    "wagmi",
    "viem",
    "@tanstack/react-query"
  ],
  "registryDependencies": [
    "dropdown-menu",
    "dialog",
    "button",
    "sonner"
  ],
  "files": [
    {
      "path": "registry/new-york/blocks/onboarding-dialog/onboarding-dialog.tsx",
      "content": "\"use client\"\n\nimport { useState, useEffect } from \"react\"\nimport { useAccount } from \"wagmi\"\nimport { cn } from \"@/lib/utils\"\nimport { type ClassValue } from \"clsx\"\nimport {\n  Dialog,\n  DialogContent,\n  DialogTitle,\n} from \"@/registry/new-york/ui/dialog\"\nimport { ConnectWalletButton } from \"@/registry/new-york/blocks/connect-wallet-button/connect-wallet-button\"\nimport { SiweButton } from \"@/registry/new-york/blocks/siwe-button/siwe-button\"\nimport { SessionKeyButton } from \"@/registry/new-york/blocks/session-keys/session-key-button\"\nimport { useSiweAuthQuery } from \"@/registry/new-york/blocks/siwe-button/hooks/use-siwe-auth-query\"\nimport { useSessionKey } from \"@/registry/new-york/blocks/session-keys/hooks/use-session-key\"\n\ninterface OnboardingDialogProps {\n  steps?: {\n    connectWallet?: boolean\n    signWithEthereum?: boolean\n    createSessionKey?: boolean\n  }\n  open?: boolean\n  onOpenChange?: (open: boolean) => void\n  onComplete?: () => void\n  onStepComplete?: (step: string) => void\n  className?: ClassValue\n}\n\ninterface StepDefinition {\n  id: string\n  title: string\n  subtitle: string\n  component: React.ComponentType<{ className?: ClassValue }>\n  validate: () => boolean\n}\n\n/**\n * Onboarding Dialog\n * \n * A configurable multi-step onboarding dialog that guides users through:\n * - Wallet connection via ConnectWalletButton\n * - SIWE authentication via SiweButton\n * - Session key creation via SessionKeyButton\n * \n * Features:\n * - Visual progress indicator showing current step\n * - Auto-detection of completed steps\n * - Configurable step selection\n * - Automatic advancement when steps complete\n */\nexport function OnboardingDialog({\n  steps = {\n    connectWallet: true,\n    signWithEthereum: true,\n    createSessionKey: true,\n  },\n  open = false,\n  onOpenChange = () => {},\n  onComplete = () => {},\n  onStepComplete,\n  className,\n}: OnboardingDialogProps) {\n  const { isConnected } = useAccount()\n  const { data: authData } = useSiweAuthQuery()\n  const { data: sessionData } = useSessionKey()\n\n  const [currentStepIndex, setCurrentStepIndex] = useState(0)\n\n  // Check authentication and session status\n  const isAuthenticated = authData?.ok && authData?.user?.isAuthenticated\n  const hasActiveSession = !!sessionData\n\n  // Define all possible steps with their validation logic\n  const allStepDefinitions: StepDefinition[] = [\n    {\n      id: 'connectWallet',\n      title: 'Connect Wallet',\n      subtitle: 'Connect your wallet to get started',\n      component: ConnectWalletButton,\n      validate: () => isConnected,\n    },\n    {\n      id: 'signWithEthereum',\n      title: 'Sign In with Ethereum',\n      subtitle: 'Sign a message to authenticate your identity',\n      component: SiweButton,\n      validate: () => !!(isConnected && isAuthenticated),\n    },\n    {\n      id: 'createSessionKey',\n      title: 'Create Session Key',\n      subtitle: 'Create a session key for seamless transactions',\n      component: SessionKeyButton,\n      validate: () => !!(isConnected && hasActiveSession),\n    },\n  ]\n\n  // Filter to only enabled steps\n  const enabledSteps = allStepDefinitions.filter(step => steps[step.id as keyof typeof steps])\n\n  // Find the first incomplete step or stay at current\n  const findCurrentStep = () => {\n    for (let i = 0; i < enabledSteps.length; i++) {\n      if (!enabledSteps[i].validate()) {\n        return i\n      }\n    }\n    return enabledSteps.length - 1 // All complete, stay at last step\n  }\n\n  // Update current step when validation changes\n  useEffect(() => {\n    if (open) {\n      const newStepIndex = findCurrentStep()\n      if (newStepIndex !== currentStepIndex) {\n        setCurrentStepIndex(newStepIndex)\n      }\n    }\n  }, [isConnected, isAuthenticated, hasActiveSession, open])\n\n  // Check if all required steps are complete\n  const allStepsComplete = enabledSteps.every(step => step.validate())\n\n  // Handle completion\n  useEffect(() => {\n    if (allStepsComplete && open && enabledSteps.length > 0) {\n      // Small delay to show completion state\n      const timer = setTimeout(() => {\n        onComplete()\n        onOpenChange(false)\n      }, 500)\n      return () => clearTimeout(timer)\n    }\n  }, [allStepsComplete, open, onComplete, onOpenChange, enabledSteps.length])\n\n  // Handle step completion callback\n  useEffect(() => {\n    if (onStepComplete && enabledSteps[currentStepIndex]?.validate()) {\n      onStepComplete(enabledSteps[currentStepIndex].id)\n    }\n  }, [currentStepIndex, onStepComplete, enabledSteps])\n\n\n  // Don't render if no steps are enabled\n  if (enabledSteps.length === 0) {\n    return null\n  }\n\n  const currentStep = enabledSteps[currentStepIndex]\n  const StepComponent = currentStep?.component\n\n  return (\n    <Dialog open={open} onOpenChange={onOpenChange}>\n      <DialogContent className={cn(\"sm:max-w-md\", className)} showCloseButton={true}>\n        <div className=\"flex flex-col items-center space-y-6\">\n          {/* Progress Dots */}\n          <div className=\"flex justify-center space-x-2\">\n            {enabledSteps.map((step, index) => (\n              <div\n                key={step.id}\n                className={cn(\n                  \"h-2 w-2 rounded-full transition-colors\",\n                  step.validate()\n                    ? \"bg-green-500\"\n                    : index === currentStepIndex\n                      ? \"bg-primary\"\n                      : \"bg-muted\"\n                )}\n              />\n            ))}\n          </div>\n\n          {/* Step Title and Description */}\n          <div className=\"text-center space-y-2\">\n            <DialogTitle className=\"text-xl font-semibold\">{currentStep?.title}</DialogTitle>\n            <p className=\"text-muted-foreground\">{currentStep?.subtitle}</p>\n          </div>\n\n          {/* Current Step Component */}\n          <div className=\"w-full\">\n            {StepComponent && (\n              <StepComponent className=\"w-full\" />\n            )}\n          </div>\n\n        </div>\n      </DialogContent>\n    </Dialog>\n  )\n}",
      "type": "registry:component"
    },
    {
      "path": "registry/new-york/blocks/onboarding-dialog/hooks/use-onboarding.ts",
      "content": "\"use client\";\n\nimport { useCallback, useMemo } from \"react\";\nimport { useAccount } from \"wagmi\";\nimport { useSiweAuthQuery } from \"@/registry/new-york/blocks/siwe-button/hooks/use-siwe-auth-query\";\nimport { useSessionKey } from \"@/registry/new-york/blocks/session-keys/hooks/use-session-key\";\nimport { requireOnboarding } from \"../lib/require-onboarding\";\n\ninterface OnboardingSteps {\n  connectWallet?: boolean;\n  signWithEthereum?: boolean;\n  createSessionKey?: boolean;\n}\n\ninterface UseOnboardingReturn {\n  ready: boolean;\n  require: () => boolean;\n  showDialog: () => void;\n  isLoading: boolean;\n  isError: boolean;\n  error?: Error;\n}\n\n/**\n * Hook for managing onboarding requirements and gating functionality\n *\n * @param steps Configuration for required onboarding steps\n * @returns Object with ready state, loading/error states, and control functions\n * @returns ready - Whether all required onboarding steps are completed\n * @returns isLoading - Whether we're loading data needed to determine onboarding state\n * @returns isError - Whether any authentication queries have errors\n * @returns error - The first error encountered, if any\n * @returns require - Function to gate actions behind onboarding completion\n * @returns showDialog - Function to manually show the onboarding dialog\n *\n * @example\n * ```tsx\n * const { ready, isLoading, isError, error, require } = useOnboarding({\n *   connectWallet: true,\n *   signWithEthereum: true,\n *   createSessionKey: false\n * })\n *\n * // Show loading state while determining onboarding status\n * if (isLoading) {\n *   return <div>Loading...</div>\n * }\n *\n * // Show error state if authentication fails\n * if (isError) {\n *   return <div>Error: {error?.message}</div>\n * }\n *\n * const handleClick = () => {\n *   if (!require()) return // Shows dialog if not ready\n *   doProtectedAction() // Only runs if onboarded\n * }\n * ```\n */\nexport function useOnboarding(steps: OnboardingSteps): UseOnboardingReturn {\n  // Get current authentication state\n  const { isConnected, isConnecting, isReconnecting } = useAccount();\n  const authQuery = useSiweAuthQuery();\n  const sessionQuery = useSessionKey();\n\n  const { data: authData } = authQuery;\n  const { data: sessionData } = sessionQuery;\n\n  // Check authentication and session status\n  const isAuthenticated = !!(authData?.ok && authData?.user?.isAuthenticated);\n  const hasActiveSession = !!sessionData;\n\n  // Show loading while we don't have enough data to determine the user's onboarding state\n  // Treat required steps with unknown state (no data and no error) as loading, but only once wallet is connected\n  const requireConnect = !!steps.connectWallet;\n  const requireAuth = !!steps.signWithEthereum;\n  const requireSession = !!steps.createSessionKey;\n\n  // Only consider auth/session loading once a wallet is connected\n  const missingAuthState =\n    requireAuth &&\n    isConnected &&\n    typeof authQuery.data === \"undefined\" &&\n    !authQuery.error;\n  const missingSessionState =\n    requireSession &&\n    isConnected &&\n    typeof sessionQuery.data === \"undefined\" &&\n    !sessionQuery.error;\n\n  // If connectWallet is required and we are not connected, don't block on loading unless we are actively connecting/reconnecting\n  const isLoading = !!(\n    isConnecting ||\n    isReconnecting ||\n    (!isConnected && requireConnect\n      ? false\n      : missingAuthState || missingSessionState)\n  );\n\n  // Debug logging\n  console.log(\"🔍 useOnboarding Debug:\", {\n    isConnected,\n    isConnecting,\n    isReconnecting,\n    \"authQuery.isLoading\": authQuery.isLoading,\n    \"authQuery.data\": !!authQuery.data,\n    \"authQuery.error\": !!authQuery.error,\n    \"sessionQuery.isLoading\": sessionQuery.isLoading,\n    \"sessionQuery.data\": !!sessionQuery.data,\n    \"sessionQuery.error\": !!sessionQuery.error,\n    isLoading,\n  });\n\n  // Aggregate error states\n  const isError = useMemo(() => {\n    return !!(authQuery.error || sessionQuery.error);\n  }, [authQuery.error, sessionQuery.error]);\n\n  // Get first error encountered for debugging\n  const error = useMemo<Error | undefined>(() => {\n    return authQuery.error || sessionQuery.error || undefined;\n  }, [authQuery.error, sessionQuery.error]);\n\n  // Check if all required steps are completed\n  const ready = useMemo(() => {\n    const stepStates = {\n      connectWallet: isConnected,\n      signWithEthereum: isConnected && isAuthenticated,\n      createSessionKey: isConnected && hasActiveSession,\n    };\n\n    return Object.entries(steps).every(([stepKey, required]) => {\n      if (!required) return true;\n      return stepStates[stepKey as keyof typeof stepStates];\n    });\n  }, [steps, isConnected, isAuthenticated, hasActiveSession]);\n\n  // Function to gate actions behind onboarding completion\n  const require = useCallback((): boolean => {\n    if (ready) {\n      // All required steps completed\n      return true;\n    } else {\n      // Missing required steps, show the onboarding modal using existing global function\n      requireOnboarding(steps, () => {\n        // This will be called when onboarding completes, but we don't need to do anything\n        // since the user's action will be in their own code after the require() call\n      });\n      return false;\n    }\n  }, [ready, steps]);\n\n  // Function to manually show the dialog\n  const showDialog = useCallback(() => {\n    requireOnboarding(steps, () => {\n      // Manual dialog show, no action needed on completion\n    });\n  }, [steps]);\n\n  // Final debug log before return\n  console.log(\"🔍 Final return values:\", { ready, isLoading, isError });\n\n  return {\n    ready,\n    require,\n    showDialog,\n    isLoading,\n    isError,\n    error,\n  };\n}\n",
      "type": "registry:hook"
    },
    {
      "path": "registry/new-york/blocks/onboarding-dialog/lib/require-onboarding.ts",
      "content": "import { useOnboardingContext } from \"./onboarding-context\"\n\ninterface OnboardingSteps {\n  connectWallet?: boolean\n  signWithEthereum?: boolean\n  createSessionKey?: boolean\n}\n\n// Global reference to the onboarding context\nlet globalRequireOnboarding: ((\n  steps: OnboardingSteps,\n  callback: () => void,\n  onComplete?: () => void\n) => void) | null = null\n\n// Hook to register the global function (used by Onboarder component)\nexport function useRegisterOnboarding() {\n  const { requireOnboarding } = useOnboardingContext()\n  \n  // Register the global function\n  if (typeof window !== \"undefined\") {\n    globalRequireOnboarding = requireOnboarding\n  }\n  \n  return requireOnboarding\n}\n\n/**\n * Global function to require onboarding (like toast() from sonner)\n * \n * @param steps - Which onboarding steps to require\n * @param callback - Function to execute when onboarding is complete\n * @param onComplete - Optional callback when onboarding dialog closes\n */\nexport function requireOnboarding(\n  steps: OnboardingSteps,\n  callback: () => void,\n  onComplete?: () => void\n) {\n  if (!globalRequireOnboarding) {\n    console.error(\n      \"requireOnboarding called before <Onboarder /> was mounted. \" +\n      \"Make sure to add <Onboarder /> to your app root.\"\n    )\n    return\n  }\n  \n  globalRequireOnboarding(steps, callback, onComplete)\n}\n\n// Convenience functions for common patterns\nexport const onboarding = {\n  /**\n   * Require wallet connection only\n   */\n  connectWallet: (callback: () => void, onComplete?: () => void) =>\n    requireOnboarding({ connectWallet: true }, callback, onComplete),\n  \n  /**\n   * Require wallet connection + SIWE auth\n   */\n  authenticate: (callback: () => void, onComplete?: () => void) =>\n    requireOnboarding(\n      { connectWallet: true, signWithEthereum: true },\n      callback,\n      onComplete\n    ),\n  \n  /**\n   * Require full onboarding (all steps)\n   */\n  full: (callback: () => void, onComplete?: () => void) =>\n    requireOnboarding(\n      {\n        connectWallet: true,\n        signWithEthereum: true,\n        createSessionKey: true,\n      },\n      callback,\n      onComplete\n    ),\n}",
      "type": "registry:lib"
    },
    {
      "path": "registry/new-york/blocks/onboarding-dialog/lib/onboarding-context.tsx",
      "content": "\"use client\"\n\nimport React, { createContext, useContext, useState, useCallback } from \"react\"\nimport { useAccount } from \"wagmi\"\nimport { useSiweAuthQuery } from \"@/registry/new-york/blocks/siwe-button/hooks/use-siwe-auth-query\"\nimport { useSessionKey } from \"@/registry/new-york/blocks/session-keys/hooks/use-session-key\"\n\ninterface OnboardingSteps {\n  connectWallet?: boolean\n  signWithEthereum?: boolean\n  createSessionKey?: boolean\n}\n\ninterface OnboardingRequest {\n  id: string\n  steps: OnboardingSteps\n  callback: () => void\n  onComplete?: () => void\n}\n\ninterface OnboardingContextType {\n  // Internal state\n  currentRequest: OnboardingRequest | null\n  isOpen: boolean\n  \n  // Public API\n  requireOnboarding: (steps: OnboardingSteps, callback: () => void, onComplete?: () => void) => void\n  \n  // Internal methods for the Onboarder component\n  _handleComplete: () => void\n  _handleClose: () => void\n  _isReady: (steps: OnboardingSteps) => boolean\n}\n\nconst OnboardingContext = createContext<OnboardingContextType | null>(null)\n\ninterface OnboardingProviderProps {\n  children: React.ReactNode\n}\n\nexport function OnboardingProvider({ children }: OnboardingProviderProps) {\n  const [currentRequest, setCurrentRequest] = useState<OnboardingRequest | null>(null)\n  const [isOpen, setIsOpen] = useState(false)\n  \n  // Get current authentication state\n  const { isConnected } = useAccount()\n  const { data: authData } = useSiweAuthQuery()\n  const { data: sessionData } = useSessionKey()\n  \n  // Check authentication and session status\n  const isAuthenticated = !!(authData?.ok && authData?.user?.isAuthenticated)\n  const hasActiveSession = !!sessionData\n  \n  // Check if required steps are completed\n  const _isReady = useCallback((steps: OnboardingSteps): boolean => {\n    const stepStates = {\n      connectWallet: isConnected,\n      signWithEthereum: isConnected && isAuthenticated,\n      createSessionKey: isConnected && hasActiveSession,\n    }\n    \n    return Object.entries(steps).every(([stepKey, required]) => {\n      if (!required) return true\n      return stepStates[stepKey as keyof typeof stepStates]\n    })\n  }, [isConnected, isAuthenticated, hasActiveSession])\n  \n  const requireOnboarding = useCallback((\n    steps: OnboardingSteps,\n    callback: () => void,\n    onComplete?: () => void\n  ) => {\n    if (_isReady(steps)) {\n      // All required steps completed, execute immediately\n      callback()\n    } else {\n      // Missing required steps, show onboarding modal\n      const request: OnboardingRequest = {\n        id: Math.random().toString(36).substr(2, 9),\n        steps,\n        callback,\n        onComplete,\n      }\n      setCurrentRequest(request)\n      setIsOpen(true)\n    }\n  }, [_isReady])\n  \n  const _handleComplete = useCallback(() => {\n    if (currentRequest) {\n      // Execute the original callback\n      currentRequest.callback()\n      \n      // Call the completion callback if provided\n      currentRequest.onComplete?.()\n      \n      // Clean up\n      setCurrentRequest(null)\n      setIsOpen(false)\n    }\n  }, [currentRequest])\n  \n  const _handleClose = useCallback(() => {\n    setIsOpen(false)\n    setCurrentRequest(null)\n  }, [])\n  \n  return (\n    <OnboardingContext.Provider\n      value={{\n        currentRequest,\n        isOpen,\n        requireOnboarding,\n        _handleComplete,\n        _handleClose,\n        _isReady,\n      }}\n    >\n      {children}\n    </OnboardingContext.Provider>\n  )\n}\n\nexport function useOnboardingContext() {\n  const context = useContext(OnboardingContext)\n  if (!context) {\n    throw new Error(\"useOnboardingContext must be used within OnboardingProvider\")\n  }\n  return context\n}",
      "type": "registry:lib"
    },
    {
      "path": "registry/new-york/blocks/onboarding-dialog/onboarder.tsx",
      "content": "\"use client\";\n\nimport { useEffect } from \"react\";\nimport {\n  OnboardingProvider,\n  useOnboardingContext,\n} from \"@/registry/new-york/blocks/onboarding-dialog/lib/onboarding-context\";\nimport { useRegisterOnboarding } from \"@/registry/new-york/blocks/onboarding-dialog/lib/require-onboarding\";\nimport { OnboardingDialog } from \"@/registry/new-york/blocks/onboarding-dialog/onboarding-dialog\";\n\nfunction OnboarderInner() {\n  const { currentRequest, isOpen, _handleComplete, _handleClose, _isReady } =\n    useOnboardingContext();\n\n  // Register the global requireOnboarding function\n  useRegisterOnboarding();\n\n  // Auto-complete if steps become ready while dialog is open\n  useEffect(() => {\n    if (currentRequest && isOpen && _isReady(currentRequest.steps)) {\n      // Small delay to show completion state\n      const timer = setTimeout(() => {\n        _handleComplete();\n      }, 500);\n      return () => clearTimeout(timer);\n    }\n  }, [currentRequest, isOpen, _isReady, _handleComplete]);\n\n  // Don't render anything if no active request\n  if (!currentRequest) {\n    return null;\n  }\n\n  return (\n    <OnboardingDialog\n      steps={currentRequest.steps}\n      open={isOpen}\n      onOpenChange={(open) => {\n        if (!open) {\n          _handleClose();\n        }\n      }}\n      onComplete={_handleComplete}\n    />\n  );\n}\n\n/**\n * Onboarder Component\n *\n * Similar to Sonner's <Toaster />, this component should be placed once at your app root.\n * It renders onboarding dialogs when requireOnboarding() is called anywhere in your app.\n *\n * Usage:\n * ```tsx\n * // In your app root (layout.tsx or _app.tsx)\n * import { Onboarder } from \"@/components/onboarder\"\n *\n * export default function RootLayout({ children }) {\n *   return (\n *     <html>\n *       <body>\n *         {children}\n *         <Onboarder />\n *       </body>\n *     </html>\n *   )\n * }\n *\n * // Anywhere in your app\n * import { requireOnboarding } from \"@/lib/require-onboarding\"\n *\n * function MyComponent() {\n *   const handleAction = () => {\n *     requireOnboarding(\n *       { connectWallet: true, signWithEthereum: true },\n *       () => console.log(\"Action executed!\")\n *     )\n *   }\n * }\n * ```\n */\nexport function Onboarder() {\n  return (\n    <OnboardingProvider>\n      <OnboarderInner />\n    </OnboardingProvider>\n  );\n}\n",
      "type": "registry:component"
    },
    {
      "path": "registry/new-york/blocks/connect-wallet-button/connect-wallet-button.tsx",
      "content": "\"use client\"\n\nimport { useLoginWithAbstract } from \"@abstract-foundation/agw-react\"\nimport { Button } from \"@/registry/new-york/ui/button\"\nimport { useAccount, useBalance } from \"wagmi\"\nimport { cn } from \"@/lib/utils\"\nimport { type ClassValue } from \"clsx\"\nimport {\n  DropdownMenu,\n  DropdownMenuContent,\n  DropdownMenuItem,\n  DropdownMenuSeparator,\n  DropdownMenuTrigger,\n} from \"@/registry/new-york/ui/dropdown-menu\"\nimport { useState } from \"react\"\n\ninterface ConnectWalletButtonProps {\n  className?: ClassValue\n  customDropdownItems?: React.ReactNode[]\n}\n\n/**\n * Connect Wallet Button for Abstract Global Wallet\n * \n * A comprehensive wallet connection component that handles:\n * - Wallet connection/disconnection via Abstract Global Wallet\n * - Loading states during connection\n * - Balance display with wallet and Abstract logos\n * - Dropdown menu with address copy functionality\n */\nexport function ConnectWalletButton({ className, customDropdownItems }: ConnectWalletButtonProps) {\n  // Wagmi hooks for wallet state and balance\n  const { isConnected, status, address } = useAccount()\n  const { data: balance, isLoading: isBalanceLoading } = useBalance({ address })\n\n  // Abstract Global Wallet authentication\n  const { login, logout } = useLoginWithAbstract()\n\n  // Local state for connection status and copy feedback\n  const isConnecting = status === 'connecting' || status === 'reconnecting'\n  const [copied, setCopied] = useState(false)\n\n  /**\n   * Copy wallet address to clipboard with visual feedback\n   */\n  const copyAddress = async () => {\n    if (address) {\n      await navigator.clipboard.writeText(address)\n      setCopied(true)\n      setTimeout(() => setCopied(false), 2000)\n    }\n  }\n\n  // Loading state: Show connecting button with spinning logo\n  if (isConnecting) {\n    return (\n      <Button\n        disabled\n        className={cn(\"cursor-pointer group min-w-40\", className)}\n      >\n        Connecting...\n        <AbstractLogo className=\"ml-2 animate-spin\" />\n      </Button>\n    )\n  }\n\n  // Disconnected state: Show connect button with hover animation\n  if (!isConnected) {\n    return (\n      <Button\n        onClick={login}\n        className={cn(\"cursor-pointer group min-w-40\", className)}\n      >\n        Connect Wallet\n        <AbstractLogo className=\"ml-2 group-hover:animate-spin transition-transform\" />\n      </Button>\n    )\n  }\n\n  // Connected but loading balance: Show loading state\n  if (isConnected && isBalanceLoading) {\n    return (\n      <Button\n        disabled\n        className={cn(\"cursor-pointer group min-w-40 px-3\", className)}\n      >\n        <WalletIcon className=\"mr-1 h-4 w-4\" />\n        Loading...\n        <AbstractLogo className=\"ml-1 h-4 w-4 animate-spin\" />\n      </Button>\n    )\n  }\n\n  // Format the balance for display (4 decimal places)\n  const formattedBalance = balance\n    ? `${parseFloat(balance.formatted).toFixed(4)} ${balance.symbol}`\n    : '0.0000 ETH'\n\n  // Connected state: Show balance with dropdown menu\n  return (\n    <DropdownMenu>\n      <DropdownMenuTrigger asChild>\n        <Button\n          className={cn(\"cursor-pointer group min-w-40 px-3\", className)}\n        >\n          <WalletIcon className=\"mr-1 h-4 w-4\" />\n          {formattedBalance}\n          <AbstractLogo className=\"ml-1 h-4 w-4\" />\n        </Button>\n      </DropdownMenuTrigger>\n      <DropdownMenuContent align=\"center\" side=\"bottom\" className=\"w-56\">\n        {/* Address display with copy functionality */}\n        <DropdownMenuItem className=\"focus:bg-transparent cursor-auto\">\n          <div className=\"flex items-center justify-between w-full\">\n            <span className=\"text-xs text-muted-foreground font-mono\">\n              {address ? `${address.slice(0, 6)}...${address.slice(-4)}` : 'Connected'}\n            </span>\n            {address && (\n              <Button\n                variant=\"ghost\"\n                size=\"sm\"\n                className=\"h-6 w-6 p-0 hover:bg-accent\"\n                onClick={(e) => {\n                  // Prevent dropdown from closing when copying\n                  e.preventDefault()\n                  e.stopPropagation()\n                  copyAddress()\n                }}\n              >\n                {copied ? (\n                  <CheckIcon className=\"h-2.5 w-2.5\" />\n                ) : (\n                  <CopyIcon className=\"h-2.5 w-2.5\" />\n                )}\n              </Button>\n            )}\n          </div>\n        </DropdownMenuItem>\n        {/* Custom dropdown items or default disconnect */}\n        {customDropdownItems ? (\n          customDropdownItems\n        ) : (\n          <>\n            <DropdownMenuSeparator />\n            <DropdownMenuItem onClick={logout} className=\"text-destructive\">\n              Disconnect\n            </DropdownMenuItem>\n          </>\n        )}\n      </DropdownMenuContent>\n    </DropdownMenu>\n  )\n}\n\nfunction WalletIcon({ className }: { className?: ClassValue }) {\n  return (\n    <svg\n      width=\"16\"\n      height=\"16\"\n      viewBox=\"0 0 640 640\"\n      xmlns=\"http://www.w3.org/2000/svg\"\n      className={cn(className)}\n    >\n      <path\n        d=\"M128 96C92.7 96 64 124.7 64 160L64 448C64 483.3 92.7 512 128 512L512 512C547.3 512 576 483.3 576 448L576 256C576 220.7 547.3 192 512 192L136 192C122.7 192 112 181.3 112 168C112 154.7 122.7 144 136 144L520 144C533.3 144 544 133.3 544 120C544 106.7 533.3 96 520 96L128 96zM480 320C497.7 320 512 334.3 512 352C512 369.7 497.7 384 480 384C462.3 384 448 369.7 448 352C448 334.3 462.3 320 480 320z\"\n        fill=\"currentColor\"\n      />\n    </svg>\n  )\n}\nfunction CopyIcon({ className }: { className?: ClassValue }) {\n  return (\n    <svg\n      width=\"16\"\n      height=\"16\"\n      viewBox=\"0 0 24 24\"\n      fill=\"none\"\n      stroke=\"currentColor\"\n      strokeWidth=\"2\"\n      strokeLinecap=\"round\"\n      strokeLinejoin=\"round\"\n      className={cn(className)}\n    >\n      <rect width=\"14\" height=\"14\" x=\"8\" y=\"8\" rx=\"2\" ry=\"2\" />\n      <path d=\"M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2\" />\n    </svg>\n  )\n}\n\nfunction CheckIcon({ className }: { className?: ClassValue }) {\n  return (\n    <svg\n      width=\"16\"\n      height=\"16\"\n      viewBox=\"0 0 24 24\"\n      fill=\"none\"\n      stroke=\"currentColor\"\n      strokeWidth=\"2\"\n      strokeLinecap=\"round\"\n      strokeLinejoin=\"round\"\n      className={cn(className)}\n    >\n      <path d=\"M20 6L9 17l-5-5\" />\n    </svg>\n  )\n}\n\nfunction AbstractLogo({ className }: { className?: ClassValue }) {\n  return (\n    <svg\n      width=\"20\"\n      height=\"18\"\n      viewBox=\"0 0 52 47\"\n      fill=\"none\"\n      xmlns=\"http://www.w3.org/2000/svg\"\n      className={cn(className)}\n    >\n      <path d=\"M33.7221 31.0658L43.997 41.3463L39.1759 46.17L28.901 35.8895C28.0201 35.0081 26.8589 34.5273 25.6095 34.5273C24.3602 34.5273 23.199 35.0081 22.3181 35.8895L12.0432 46.17L7.22205 41.3463L17.4969 31.0658H33.7141H33.7221Z\" fill=\"currentColor\" />\n      <path d=\"M35.4359 28.101L49.4668 31.8591L51.2287 25.2645L37.1978 21.5065C35.9965 21.186 34.9954 20.4167 34.3708 19.335C33.7461 18.2613 33.586 17.0033 33.9063 15.8013L37.6623 1.76283L31.0713 0L27.3153 14.0385L35.4279 28.093L35.4359 28.101Z\" fill=\"currentColor\" />\n      <path d=\"M15.7912 28.101L1.76028 31.8591L-0.00158691 25.2645L14.0293 21.5065C15.2306 21.186 16.2316 20.4167 16.8563 19.335C17.4809 18.2613 17.6411 17.0033 17.3208 15.8013L13.5648 1.76283L20.1558 0L23.9118 14.0385L15.7992 28.093L15.7912 28.101Z\" fill=\"currentColor\" />\n    </svg>\n  )\n}",
      "type": "registry:component"
    },
    {
      "path": "registry/new-york/blocks/siwe-button/siwe-button.tsx",
      "content": "\"use client\";\n\nimport { useAccount } from \"wagmi\";\nimport { Button } from \"@/registry/new-york/ui/button\";\nimport { DropdownMenuItem, DropdownMenuSeparator } from \"@/registry/new-york/ui/dropdown-menu\";\nimport { ConnectWalletButton } from \"@/registry/new-york/blocks/connect-wallet-button/connect-wallet-button\";\nimport { useSiweAuthQuery } from \"@/registry/new-york/blocks/siwe-button/hooks/use-siwe-auth-query\";\nimport { useSiweSignInMutation } from \"@/registry/new-york/blocks/siwe-button/hooks/use-siwe-sign-in-mutation\";\nimport { useSiweLogoutMutation } from \"@/registry/new-york/blocks/siwe-button/hooks/use-siwe-logout-mutation\";\nimport { cn } from \"@/lib/utils\";\nimport { type ClassValue } from \"clsx\";\n\ninterface SiweButtonProps {\n  className?: ClassValue;\n}\n\n/**\n * SIWE Button\n * \n * A streamlined authentication button that handles:\n * - Wallet connection via ConnectWalletButton integration\n * - SIWE message signing and verification\n * - Authentication state management with balance display\n * - Loading states and error handling via toast notifications\n * \n * States:\n * - Not connected: Shows \"Connect Wallet\" button\n * - Connected but not authenticated: Shows \"Sign Message\" button  \n * - Authenticated: Shows balance with dropdown containing \"Sign Out\"\n */\nexport function SiweButton({ className }: SiweButtonProps) {\n  const { isConnected } = useAccount();\n  const { data: authData, isLoading: isAuthLoading } = useSiweAuthQuery();\n  const signInMutation = useSiweSignInMutation();\n  const logoutMutation = useSiweLogoutMutation();\n\n  // Check if user is authenticated\n  const isAuthenticated = authData?.ok && authData?.user?.isAuthenticated;\n\n  // Handle sign-in action\n  const handleSignIn = () => {\n    signInMutation.mutate();\n  };\n\n  // Handle sign-out action (SIWE logout + wallet disconnect)\n  const handleSignOut = () => {\n    logoutMutation.mutate();\n  };\n\n  // Not connected: Use ConnectWalletButton\n  if (!isConnected) {\n    return <ConnectWalletButton className={className} />;\n  }\n\n  // Connected and authenticated: Use ConnectWalletButton with custom dropdown\n  if (isConnected && isAuthenticated) {\n    return (\n      <ConnectWalletButton \n        className={className}\n        customDropdownItems={[\n          <DropdownMenuSeparator key=\"sep\" />,\n          <DropdownMenuItem \n            key=\"signout\" \n            onClick={handleSignOut}\n            disabled={logoutMutation.isPending}\n            className=\"text-destructive\"\n          >\n            {logoutMutation.isPending ? (\n              <>\n                <Spinner className=\"mr-2 h-4 w-4 animate-spin\" />\n                Signing out...\n              </>\n            ) : (\n              \"Sign Out\"\n            )}\n          </DropdownMenuItem>\n        ]}\n      />\n    );\n  }\n\n  // Connected but not authenticated OR loading: Show Sign Message button\n  return (\n    <Button\n      onClick={handleSignIn}\n      disabled={signInMutation.isPending || isAuthLoading}\n      className={cn(\"cursor-pointer group min-w-40\", className)}\n    >\n      {signInMutation.isPending ? (\n        <>\n          <Spinner className=\"mr-2 h-4 w-4 animate-spin\" />\n          Signing in...\n        </>\n      ) : isAuthLoading ? (\n        <>\n          <Spinner className=\"mr-2 h-4 w-4 animate-spin\" />\n          Checking...\n        </>\n      ) : (\n        <>\n          <KeyIcon className=\"mr-2 h-4 w-4\" />\n          Sign Message\n        </>\n      )}\n    </Button>\n  );\n}\n\nfunction Spinner({ className }: { className?: ClassValue }) {\n  return (\n    <svg\n      className={cn(\"animate-spin\", className)}\n      xmlns=\"http://www.w3.org/2000/svg\"\n      fill=\"none\"\n      viewBox=\"0 0 24 24\"\n    >\n      <circle\n        className=\"opacity-25\"\n        cx=\"12\"\n        cy=\"12\"\n        r=\"10\"\n        stroke=\"currentColor\"\n        strokeWidth=\"4\"\n      />\n      <path\n        className=\"opacity-75\"\n        fill=\"currentColor\"\n        d=\"m4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z\"\n      />\n    </svg>\n  );\n}\n\nfunction KeyIcon({ className }: { className?: ClassValue }) {\n  return (\n    <svg\n      className={cn(className)}\n      xmlns=\"http://www.w3.org/2000/svg\"\n      fill=\"none\"\n      viewBox=\"0 0 24 24\"\n      stroke=\"currentColor\"\n      strokeWidth=\"2\"\n    >\n      <path\n        strokeLinecap=\"round\"\n        strokeLinejoin=\"round\"\n        d=\"M15.75 5.25a3 3 0 013 3m3 0a6 6 0 01-7.029 5.912c-.563-.097-1.159.026-1.563.43L10.5 17.25H8.25v2.25H6v2.25H2.25v-2.818c0-.597.237-1.17.659-1.591l6.499-6.499c.404-.404.527-1 .43-1.563A6 6 0 1121.75 8.25z\"\n      />\n    </svg>\n  );\n}",
      "type": "registry:component"
    },
    {
      "path": "registry/new-york/blocks/siwe-button/hooks/use-siwe-auth-query.ts",
      "content": "\"use client\";\n\nimport { useQuery } from \"@tanstack/react-query\";\nimport { useAccount } from \"wagmi\";\nimport { AuthResponse, ClientSiweConfigurationError } from \"@/registry/new-york/blocks/siwe-button/lib/types\";\n\nconst QUERY_KEYS = {\n  auth: \"siwe-auth\",\n} as const;\n\nasync function fetchAuthUser(): Promise<AuthResponse> {\n  const response = await fetch(\"/api/auth/user\");\n  const result = await response.json();\n\n  // Check for configuration errors and throw proper error type\n  if (result.isConfigurationError) {\n    throw new ClientSiweConfigurationError(result.message);\n  }\n\n  return result;\n}\n\nexport function useSiweAuthQuery() {\n  const { address, isConnected } = useAccount();\n\n  const query = useQuery({\n    queryKey: [QUERY_KEYS.auth, address],\n    queryFn: fetchAuthUser,\n    // Only run query if wallet is connected\n    enabled: isConnected && !!address,\n    // Consider auth data is fresh for 1 minute\n    staleTime: 1000 * 60 * 1, // 1 minute\n    // Only refetch on window focus if data is stale (not on every tab switch)\n    refetchOnWindowFocus: true,\n    // Always recheck when network reconnects\n    refetchOnReconnect: true,\n    // Background recheck every 5 minutes\n    refetchInterval: 1000 * 60 * 5, // 5 minutes\n    // Keep auth data in cache for 10 minutes after component unmount\n    gcTime: 1000 * 60 * 10, // 10 minutes\n    retry: (failureCount, error: Error & { status?: number }) => {\n      // Don't retry if it's a 401 (not authenticated)\n      if (error?.status === 401) {\n        return false;\n      }\n      // Don't retry configuration errors - let them throw\n      if (error instanceof ClientSiweConfigurationError) {\n        return false;\n      }\n      // Retry up to 2 times for other errors\n      return failureCount < 2;\n    },\n    retryDelay: attemptIndex => Math.min(1000 * 2 ** attemptIndex, 30000),\n  });\n\n  // If there's a configuration error, throw it during render to show in Next.js overlay\n  if (query.error instanceof ClientSiweConfigurationError) {\n    throw query.error;\n  }\n\n  return query;\n}",
      "type": "registry:hook"
    },
    {
      "path": "registry/new-york/blocks/siwe-button/hooks/use-siwe-sign-in-mutation.ts",
      "content": "\"use client\";\n\nimport { useMutation, useQueryClient } from \"@tanstack/react-query\";\nimport { useAccount, useSignMessage } from \"wagmi\";\nimport { createSiweMessage } from \"viem/siwe\";\nimport { toast } from \"sonner\";\nimport { AuthResponse, SignInRequest, ClientSiweConfigurationError } from \"@/registry/new-york/blocks/siwe-button/lib/types\";\n\nasync function fetchNonce(): Promise<string> {\n  const response = await fetch(\"/api/auth/nonce\");\n  \n  // Check if it's a JSON error response (configuration error)\n  const contentType = response.headers.get(\"content-type\");\n  if (contentType?.includes(\"application/json\")) {\n    const errorData = await response.json();\n    if (errorData.isConfigurationError) {\n      // Throw the configuration error to bubble up to Next.js\n      throw new ClientSiweConfigurationError(errorData.message);\n    }\n    throw new Error(errorData.message || \"Failed to fetch nonce\");\n  }\n  \n  return response.text();\n}\n\nasync function verifySignature(data: SignInRequest): Promise<AuthResponse> {\n  const response = await fetch(\"/api/auth/verify\", {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n    body: JSON.stringify(data),\n  });\n  \n  const result = await response.json();\n  \n  // Check for configuration errors and throw them to bubble up\n  if (result.isConfigurationError) {\n    throw new ClientSiweConfigurationError(result.message);\n  }\n  \n  return result;\n}\n\nexport function useSiweSignInMutation() {\n  const { address, chainId } = useAccount();\n  const { signMessageAsync } = useSignMessage();\n  const queryClient = useQueryClient();\n\n  return useMutation({\n    mutationFn: async () => {\n      if (!address || !chainId) {\n        throw new Error(\"Wallet not connected\");\n      }\n\n      // Step 1: Fetch nonce\n      const nonce = await fetchNonce();\n\n      // Step 2: Create SIWE message\n      const message = createSiweMessage({\n        domain: window.location.host,\n        address,\n        statement: \"Sign in with Ethereum to the app.\",\n        uri: window.location.origin,\n        version: \"1\",\n        chainId,\n        nonce,\n        issuedAt: new Date(),\n        expirationTime: new Date(Date.now() + 1000 * 60 * 60 * 24 * 7), // 1 week\n      });\n\n      // Step 3: Sign the message\n      const signature = await signMessageAsync({\n        message,\n      });\n\n      // Step 4: Verify signature\n      const result = await verifySignature({\n        message,\n        signature: signature as `0x${string}`,\n      });\n\n      if (!result.ok) {\n        throw new Error(result.message || \"Sign-in failed\");\n      }\n\n      return result;\n    },\n    onSuccess: () => {\n      // Invalidate auth query to refresh user state\n      queryClient.invalidateQueries({ queryKey: [\"siwe-auth\"] });\n      toast.success(\"Successfully signed in!\");\n    },\n    onError: (error: Error) => {\n      // If it's a configuration error, throw it to show in Next.js overlay\n      if (error instanceof ClientSiweConfigurationError) {\n        throw error;\n      }\n      // Otherwise handle normally\n      console.error(\"Sign-in error:\", error);\n      toast.error(error.message || \"Failed to sign in\");\n    },\n  });\n}",
      "type": "registry:hook"
    },
    {
      "path": "registry/new-york/blocks/siwe-button/hooks/use-siwe-logout-mutation.ts",
      "content": "\"use client\";\n\nimport { useMutation, useQueryClient } from \"@tanstack/react-query\";\nimport { useLoginWithAbstract } from \"@abstract-foundation/agw-react\";\nimport { toast } from \"sonner\";\nimport { ClientSiweConfigurationError } from \"@/registry/new-york/blocks/siwe-button/lib/types\";\n\nconst QUERY_KEYS = {\n  auth: \"siwe-auth\",\n} as const;\n\ninterface LogoutResponse {\n  ok: boolean;\n  message?: string;\n  isConfigurationError?: boolean;\n}\n\nasync function logoutUser(): Promise<LogoutResponse> {\n  const response = await fetch(\"/api/auth/logout\", {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n  });\n  \n  const result = await response.json();\n  \n  // Check for configuration errors and throw proper error type\n  if (result.isConfigurationError) {\n    throw new ClientSiweConfigurationError(result.message);\n  }\n  \n  if (!response.ok) {\n    throw new Error(result.message || \"Logout failed\");\n  }\n  \n  return result;\n}\n\n/**\n * React Query mutation hook for SIWE logout functionality.\n * Handles the logout process and updates auth state.\n * \n * @returns UseMutationResult for logout operation\n * \n * @example\n * ```tsx\n * import { useSiweLogoutMutation } from \"@/registry/new-york/blocks/siwe-button/hooks/use-siwe-logout-mutation\";\n * \n * function LogoutButton() {\n *   const logoutMutation = useSiweLogoutMutation();\n *   \n *   return (\n *     <button \n *       onClick={() => logoutMutation.mutate()}\n *       disabled={logoutMutation.isPending}\n *     >\n *       {logoutMutation.isPending ? \"Signing out...\" : \"Sign Out\"}\n *     </button>\n *   );\n * }\n * ```\n * \n * @example\n * ```tsx\n * // With custom success/error handling\n * function MyComponent() {\n *   const logoutMutation = useSiweLogoutMutation({\n *     onSuccess: () => {\n *       // Custom success handling\n *       router.push(\"/\");\n *     },\n *     onError: (error) => {\n *       // Custom error handling\n *       console.error(\"Logout failed:\", error);\n *     }\n *   });\n * \n *   return (\n *     <button onClick={() => logoutMutation.mutate()}>\n *       Sign Out\n *     </button>\n *   );\n * }\n * ```\n */\nexport function useSiweLogoutMutation(options?: {\n  onSuccess?: () => void;\n  onError?: (error: Error) => void;\n}) {\n  const queryClient = useQueryClient();\n  const { logout: walletLogout } = useLoginWithAbstract();\n\n  const mutation = useMutation({\n    mutationFn: logoutUser,\n    onSuccess: (data) => {\n      // Immediately reset auth query data to logged out state\n      queryClient.setQueryData([QUERY_KEYS.auth], {\n        ok: false,\n        message: \"Logged out\"\n      });\n      \n      // Also invalidate to trigger refetch\n      queryClient.invalidateQueries({ queryKey: [QUERY_KEYS.auth] });\n      \n      // Disconnect wallet for complete logout experience\n      walletLogout();\n      \n      // Show success toast\n      toast.success(\"Successfully signed out\");\n      \n      // Call custom success handler if provided\n      options?.onSuccess?.();\n    },\n    onError: (error: Error) => {\n      // Don't show error toast for configuration errors - they should be thrown\n      if (error instanceof ClientSiweConfigurationError) {\n        throw error;\n      }\n      \n      // Show error toast for other errors\n      toast.error(error.message || \"Sign out failed\");\n      \n      // Call custom error handler if provided\n      options?.onError?.(error);\n    },\n  });\n\n  // If there's a configuration error, throw it during render to show in Next.js overlay\n  if (mutation.error instanceof ClientSiweConfigurationError) {\n    throw mutation.error;\n  }\n\n  return mutation;\n}",
      "type": "registry:hook"
    },
    {
      "path": "registry/new-york/blocks/siwe-button/lib/types.ts",
      "content": "\nexport interface SessionData {\n  nonce?: string;\n  isAuthenticated?: boolean;\n  address?: `0x${string}`;\n  chainId?: number;\n  expirationTime?: string;\n}\n\nexport interface AuthUser {\n  isAuthenticated: boolean;\n  address: `0x${string}`;\n  chainId?: number;\n  expirationTime?: string;\n}\n\nexport interface AuthResponse {\n  ok: boolean;\n  message?: string;\n  user?: AuthUser;\n  isConfigurationError?: boolean;\n}\n\nexport interface ConfigurationErrorResponse {\n  ok: false;\n  isConfigurationError: true;\n  message: string;\n}\n\n/**\n * Client-side configuration error that matches the server-side SiweConfigurationError\n */\nexport class ClientSiweConfigurationError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = \"SiweConfigurationError\";\n  }\n}\n\nexport interface SignInRequest {\n  message: string;\n  signature: `0x${string}`;\n}",
      "type": "registry:lib"
    },
    {
      "path": "config/auth.ts",
      "content": "import { SessionOptions } from \"iron-session\";\n/**\n * Custom error class for SIWE authentication configuration issues.\n * These errors bubble up to show helpful messages.\n */\nexport class SiweConfigurationError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = \"SiweConfigurationError\";\n  }\n}\n\n/**\n * Validates and returns the Iron Session password from environment variables.\n * Throws a SiweConfigurationError if not properly configured.\n */\nfunction getSessionPassword(): string {\n  const password = process.env.IRON_SESSION_PASSWORD;\n\n  if (!password) {\n    throw new SiweConfigurationError(\n      \"IRON_SESSION_PASSWORD environment variable is required for SIWE authentication.\\n\\n\" +\n      \"This password is used to encrypt session data and must be cryptographically secure.\\n\\n\" +\n      \"To fix this:\\n\" +\n      \"1. Generate a secure password: openssl rand -base64 32\\n\" +\n      \"2. Add it to your .env.local file:\\n\" +\n      '   IRON_SESSION_PASSWORD=\"your_generated_password_here\"\\n' +\n      \"3. Restart your application\\n\\n\" +\n      \"SECURITY WARNING: Never use a weak or default password in production!\"\n    );\n  }\n\n  if (password.length < 32) {\n    throw new SiweConfigurationError(\n      \"IRON_SESSION_PASSWORD must be at least 32 characters long for security.\\n\" +\n      \"Generate a new secure password using: openssl rand -base64 32\"\n    );\n  }\n\n  return password;\n}\n\n/**\n * Gets Iron Session configuration for SIWE authentication.\n * Validates IRON_SESSION_PASSWORD on first call.\n */\nexport function getIronOptions(): SessionOptions {\n  return {\n    password: getSessionPassword(),\n    cookieName: \"siwe-session\",\n    cookieOptions: {\n      secure: process.env.NODE_ENV === \"production\",\n      httpOnly: true,\n      sameSite: \"strict\",\n      maxAge: 60 * 60 * 24 * 7, // 7 days\n    },\n  };\n}",
      "type": "registry:lib",
      "target": "config/auth.ts"
    },
    {
      "path": "config/chain.ts",
      "content": "import { abstractTestnet } from \"viem/chains\";\n\nexport const chain =\n  process.env.NODE_ENV === \"development\"\n    ? abstractTestnet // Local development: Use Abstract Testnet\n    : abstractTestnet; // Production: Use Abstract Testnet (change to mainnet when ready)\n",
      "type": "registry:lib",
      "target": "config/chain.ts"
    },
    {
      "path": "registry/new-york/blocks/siwe-button/lib/auth-server.ts",
      "content": "import { getIronSession } from \"iron-session\";\nimport { cookies } from \"next/headers\";\nimport { SessionData } from \"@/app/api/auth/nonce/route\";\nimport { getIronOptions, SiweConfigurationError } from \"@/config/auth\";\nimport { chain } from \"@/config/chain\";\nimport { AuthUser } from \"./types\";\n\n/**\n * Server-side authentication utilities for SIWE (Sign-in with Ethereum).\n * These functions provide safe and convenient ways to check authentication state\n * on the server-side in API routes, Server Components, and middleware.\n */\n\nexport interface ServerAuthResult {\n  isAuthenticated: boolean;\n  user?: AuthUser;\n  error?: string;\n}\n\n/**\n * Safely retrieves the current authenticated user from the server-side session.\n * Returns null if not authenticated or if there's an error.\n * \n * @returns Promise<ServerAuthResult> - Authentication result with user data or error\n * \n * @example\n * ```tsx\n * // In a Server Component\n * import { getServerAuthUser } from \"@/registry/new-york/blocks/siwe-auth/lib/auth-server\";\n * \n * export default async function ProtectedPage() {\n *   const auth = await getServerAuthUser();\n *   \n *   if (!auth.isAuthenticated) {\n *     return <div>Please sign in to access this page</div>;\n *   }\n *   \n *   return (\n *     <div>\n *       <h1>Welcome!</h1>\n *       <p>Your address: {auth.user?.address}</p>\n *     </div>\n *   );\n * }\n * ```\n * \n * @example\n * ```tsx\n * // In an API route\n * import { getServerAuthUser } from \"@/registry/new-york/blocks/siwe-auth/lib/auth-server\";\n * \n * export async function GET() {\n *   const auth = await getServerAuthUser();\n *   \n *   if (!auth.isAuthenticated) {\n *     return NextResponse.json({ error: \"Unauthorized\" }, { status: 401 });\n *   }\n *   \n *   // Access protected data\n *   const userData = await getUserData(auth.user!.address);\n *   return NextResponse.json(userData);\n * }\n * ```\n */\nexport async function getServerAuthUser(): Promise<ServerAuthResult> {\n  try {\n    const session = await getIronSession<SessionData>(\n      await cookies(),\n      getIronOptions()\n    );\n\n    // Check if user is authenticated\n    if (!session.isAuthenticated || !session.address) {\n      return {\n        isAuthenticated: false,\n        error: \"No user session found\"\n      };\n    }\n\n    // Check if session is expired\n    if (\n      session.expirationTime &&\n      new Date(session.expirationTime).getTime() < Date.now()\n    ) {\n      return {\n        isAuthenticated: false,\n        error: \"SIWE session expired\"\n      };\n    }\n\n    // Check if chain matches\n    if (session.chainId !== chain.id) {\n      return {\n        isAuthenticated: false,\n        error: \"Invalid chain\"\n      };\n    }\n\n    // Return authenticated user data\n    return {\n      isAuthenticated: true,\n      user: {\n        isAuthenticated: session.isAuthenticated,\n        address: session.address,\n        chainId: session.chainId,\n        expirationTime: session.expirationTime,\n      }\n    };\n  } catch (error) {\n    // Handle configuration errors\n    if (error instanceof SiweConfigurationError) {\n      return {\n        isAuthenticated: false,\n        error: `Configuration error: ${error.message}`\n      };\n    }\n\n    // Handle unexpected errors\n    return {\n      isAuthenticated: false,\n      error: \"Authentication check failed\"\n    };\n  }\n}\n\n/**\n * Requires authentication and throws an error if not authenticated.\n * Useful for API routes that need to ensure authentication.\n * \n * @returns Promise<AuthUser> - The authenticated user data\n * @throws Error if not authenticated\n * \n * @example\n * ```tsx\n * // In an API route\n * import { requireServerAuth } from \"@/registry/new-york/blocks/siwe-auth/lib/auth-server\";\n * \n * export async function POST(request: Request) {\n *   try {\n *     const user = await requireServerAuth();\n *     \n *     // User is guaranteed to be authenticated here\n *     const result = await performProtectedAction(user.address);\n *     return NextResponse.json(result);\n *     \n *   } catch (error) {\n *     return NextResponse.json(\n *       { error: error.message }, \n *       { status: 401 }\n *     );\n *   }\n * }\n * ```\n */\nexport async function requireServerAuth(): Promise<AuthUser> {\n  const auth = await getServerAuthUser();\n\n  if (!auth.isAuthenticated || !auth.user) {\n    throw new Error(auth.error || \"Authentication required\");\n  }\n\n  return auth.user;\n}\n\n/**\n * Checks if a user is authenticated (boolean check only).\n * Useful for conditional rendering or simple auth checks.\n * \n * @returns Promise<boolean> - True if authenticated, false otherwise\n * \n * @example\n * ```tsx\n * // In a Server Component\n * import { isServerAuthenticated } from \"@/registry/new-york/blocks/siwe-auth/lib/auth-server\";\n * \n * export default async function HomePage() {\n *   const isAuthenticated = await isServerAuthenticated();\n *   \n *   return (\n *     <div>\n *       {isAuthenticated ? (\n *         <p>Welcome back!</p>\n *       ) : (\n *         <p>Please sign in</p>\n *       )}\n *     </div>\n *   );\n * }\n * ```\n */\nexport async function isServerAuthenticated(): Promise<boolean> {\n  const auth = await getServerAuthUser();\n  return auth.isAuthenticated;\n}\n\n/**\n * Gets the authenticated user's address safely.\n * Returns null if not authenticated.\n * \n * @returns Promise<string | null> - The user's address or null\n * \n * @example\n * ```tsx\n * // In an API route\n * import { getServerAuthAddress } from \"@/registry/new-york/blocks/siwe-auth/lib/auth-server\";\n * \n * export async function GET() {\n *   const address = await getServerAuthAddress();\n *   \n *   if (!address) {\n *     return NextResponse.json({ error: \"Unauthorized\" }, { status: 401 });\n *   }\n *   \n *   const balance = await getBalance(address);\n *   return NextResponse.json({ address, balance });\n * }\n * ```\n */\nexport async function getServerAuthAddress(): Promise<`0x${string}` | null> {\n  const auth = await getServerAuthUser();\n  return auth.user?.address || null;\n}",
      "type": "registry:lib"
    },
    {
      "path": "app/api/auth/nonce/route.ts",
      "content": "// Hello world\nimport { cookies } from \"next/headers\";\nimport { NextResponse } from \"next/server\";\nimport { generateSiweNonce } from \"viem/siwe\";\nimport { getIronSession } from \"iron-session\";\nimport { getIronOptions, SiweConfigurationError } from \"@/config/auth\";\n\nexport interface SessionData {\n  nonce?: string;\n  isAuthenticated?: boolean;\n  address?: `0x${string}`;\n  chainId?: number;\n  expirationTime?: string;\n}\n\n/**\n * Sign in with Ethereum - Generate a unique nonce for the SIWE message.\n */\nexport async function GET() {\n  try {\n    // The \"session\" here is not related to our session keys.\n    // This is just related to auth / sign in with Ethereum.\n    const session = await getIronSession<SessionData>(\n      await cookies(),\n      getIronOptions()\n    );\n\n    // Generate and store the nonce\n    const nonce = generateSiweNonce();\n    session.nonce = nonce;\n    await session.save();\n\n    // Return the nonce as plain text with no-cache headers\n    return new NextResponse(nonce, {\n      headers: {\n        \"Cache-Control\":\n          \"no-store, no-cache, must-revalidate, proxy-revalidate\",\n        Pragma: \"no-cache\",\n        Expires: \"0\",\n      },\n    });\n  } catch (error) {\n    // Return configuration errors as special response type\n    if (error instanceof SiweConfigurationError) {\n      return NextResponse.json(\n        {\n          ok: false,\n          isConfigurationError: true,\n          message: error.message,\n        },\n        { status: 500 }\n      );\n    }\n    // Catch other unexpected errors\n    return NextResponse.json({ ok: false }, { status: 500 });\n  }\n}\n",
      "type": "registry:page",
      "target": "app/api/auth/nonce/route.ts"
    },
    {
      "path": "app/api/auth/verify/route.ts",
      "content": "import { NextRequest, NextResponse } from \"next/server\";\nimport { parseSiweMessage } from \"viem/siwe\";\nimport { getIronSession } from \"iron-session\";\nimport { cookies } from \"next/headers\";\nimport { SessionData } from \"../nonce/route\";\nimport { createPublicClient, http } from \"viem\";\nimport { getIronOptions, SiweConfigurationError } from \"@/config/auth\";\nimport { chain } from \"@/config/chain\";\n\nexport async function POST(request: NextRequest) {\n  try {\n    const body = await request.json();\n    const { message, signature } = body;\n\n    // Validate required fields\n    if (!message || !signature) {\n      return NextResponse.json(\n        { ok: false, message: \"Message and signature are required.\" },\n        { status: 400 }\n      );\n    }\n\n    // Validate message is a string\n    if (typeof message !== 'string') {\n      return NextResponse.json(\n        { ok: false, message: \"Message must be a string.\" },\n        { status: 400 }\n      );\n    }\n\n    // Validate signature is a valid hex string (supports both EOA and EIP-1271 signatures)\n    if (typeof signature !== 'string' || !/^0x[a-fA-F0-9]+$/.test(signature) || signature.length < 4) {\n      return NextResponse.json(\n        { ok: false, message: \"Invalid signature format.\" },\n        { status: 400 }\n      );\n    }\n\n    // The \"session\" here is not related to our session keys.\n    // This is just related to auth / sign in with Ethereum.\n    const session = await getIronSession<SessionData>(\n      await cookies(),\n      getIronOptions()\n    );\n\n    const publicClient = createPublicClient({\n      chain,\n      transport: http(),\n    });\n\n    try {\n      // Validate nonce exists\n      if (!session.nonce) {\n        return NextResponse.json(\n          { ok: false, message: \"No nonce found. Please request a new nonce first.\" },\n          { status: 422 }\n        );\n      }\n\n      // Parse and validate SIWE message before signature verification\n      const siweMessage = parseSiweMessage(message);\n\n      // Validate chain ID matches expected chain\n      if (siweMessage.chainId !== chain.id) {\n        return NextResponse.json(\n          { ok: false, message: \"Invalid chain ID.\" },\n          { status: 422 }\n        );\n      }\n\n      // Validate domain matches current host to prevent cross-domain replay attacks\n      const requestHost = request.headers.get(\"host\");\n      if (siweMessage.domain !== requestHost) {\n        return NextResponse.json(\n          { ok: false, message: \"Invalid domain.\" },\n          { status: 422 }\n        );\n      }\n\n      // Validate message expiration time\n      if (siweMessage.expirationTime && siweMessage.expirationTime.getTime() <= Date.now()) {\n        return NextResponse.json(\n          { ok: false, message: \"Message has expired.\" },\n          { status: 422 }\n        );\n      }\n\n      // Create and verify the SIWE message (with EIP-1271 support for smart contract wallets)\n      const valid = await publicClient.verifySiweMessage({\n        message,\n        signature: signature as `0x${string}`,\n        nonce: session.nonce,\n        blockTag: 'latest', // EIP-1271 smart contract wallet support\n      });\n\n      // Clear nonce after any verification attempt to prevent reuse\n      session.nonce = undefined;\n\n      // If verification is successful, update the auth state\n      if (valid) {\n        session.isAuthenticated = true;\n        session.address = siweMessage.address as `0x${string}`;\n        session.chainId = siweMessage.chainId;\n        session.expirationTime = siweMessage.expirationTime?.toISOString();\n        await session.save();\n      } else {\n        // Save session to persist nonce clearing even on failure\n        await session.save();\n      }\n\n      if (!valid) {\n        return NextResponse.json(\n          { ok: false, message: \"Invalid signature.\" },\n          { status: 422 }\n        );\n      }\n    } catch {\n      return NextResponse.json(\n        { ok: false, message: \"Verification failed\" },\n        { status: 500 }\n      );\n    }\n\n    return NextResponse.json({ ok: true });\n  } catch (error) {\n    // Return configuration errors as special response type\n    if (error instanceof SiweConfigurationError) {\n      return NextResponse.json({\n        ok: false,\n        isConfigurationError: true,\n        message: error.message\n      }, { status: 500 });\n    }\n    // Catch other unexpected errors\n    return NextResponse.json({ ok: false }, { status: 500 });\n  }\n}",
      "type": "registry:page",
      "target": "app/api/auth/verify/route.ts"
    },
    {
      "path": "app/api/auth/user/route.ts",
      "content": "import { NextResponse } from \"next/server\";\nimport { getIronSession } from \"iron-session\";\nimport { cookies } from \"next/headers\";\nimport { SessionData } from \"../nonce/route\";\nimport { getIronOptions, SiweConfigurationError } from \"@/config/auth\";\nimport { chain } from \"@/config/chain\";\n\n/**\n * Sign in with Ethereum - Get the currently authenticated user information.\n * @returns\n */\nexport async function GET() {\n  try {\n    // The \"session\" here is not related to our session keys.\n    // This is just related to auth / sign in with Ethereum.\n    const session = await getIronSession<SessionData>(\n      await cookies(),\n      getIronOptions()\n    );\n\n    if (!session.isAuthenticated || !session.address) {\n      return NextResponse.json(\n        { ok: false, message: \"No user session found.\" },\n        { status: 401 }\n      );\n    }\n\n    if (\n      session.expirationTime &&\n      new Date(session.expirationTime).getTime() < Date.now()\n    ) {\n      return NextResponse.json(\n        { ok: false, message: \"SIWE session expired.\" },\n        { status: 401 }\n      );\n    }\n\n    if (session.chainId !== chain.id) {\n      return NextResponse.json(\n        { ok: false, message: \"Invalid chain.\" },\n        { status: 401 }\n      );\n    }\n\n    // Return the SIWE session data\n    return NextResponse.json({\n      ok: true,\n      user: {\n        isAuthenticated: session.isAuthenticated,\n        address: session.address,\n        chainId: session.chainId,\n        expirationTime: session.expirationTime,\n      },\n    });\n  } catch (error) {\n    // Return configuration errors as special response type\n    if (error instanceof SiweConfigurationError) {\n      return NextResponse.json({\n        ok: false,\n        isConfigurationError: true,\n        message: error.message\n      }, { status: 500 });\n    }\n    // Catch other unexpected errors\n    return NextResponse.json({ ok: false }, { status: 500 });\n  }\n}",
      "type": "registry:page",
      "target": "app/api/auth/user/route.ts"
    },
    {
      "path": "app/api/auth/logout/route.ts",
      "content": "import { NextResponse } from \"next/server\";\nimport { getIronSession } from \"iron-session\";\nimport { cookies } from \"next/headers\";\nimport { SessionData } from \"../nonce/route\";\nimport { getIronOptions, SiweConfigurationError } from \"@/config/auth\";\n\n/**\n * Sign in with Ethereum - Logout and destroy the current session.\n */\nexport async function POST() {\n  try {\n    const session = await getIronSession<SessionData>(\n      await cookies(),\n      getIronOptions()\n    );\n\n    // Clear all session data\n    session.isAuthenticated = false;\n    session.address = undefined;\n    session.chainId = undefined;\n    session.expirationTime = undefined;\n    session.nonce = undefined;\n    \n    // Destroy the session\n    session.destroy();\n\n    return NextResponse.json({ ok: true, message: \"Successfully logged out\" });\n  } catch (error) {\n    // Let configuration errors bubble up to show helpful messages\n    if (error instanceof SiweConfigurationError) {\n      throw error;\n    }\n    // Catch other unexpected errors\n    return NextResponse.json({ ok: false }, { status: 500 });\n  }\n}",
      "type": "registry:page",
      "target": "app/api/auth/logout/route.ts"
    },
    {
      "path": "registry/new-york/blocks/onboarding-dialog/onboarding-dialog.tsx",
      "content": "\"use client\"\n\nimport { useState, useEffect } from \"react\"\nimport { useAccount } from \"wagmi\"\nimport { cn } from \"@/lib/utils\"\nimport { type ClassValue } from \"clsx\"\nimport {\n  Dialog,\n  DialogContent,\n  DialogTitle,\n} from \"@/registry/new-york/ui/dialog\"\nimport { ConnectWalletButton } from \"@/registry/new-york/blocks/connect-wallet-button/connect-wallet-button\"\nimport { SiweButton } from \"@/registry/new-york/blocks/siwe-button/siwe-button\"\nimport { SessionKeyButton } from \"@/registry/new-york/blocks/session-keys/session-key-button\"\nimport { useSiweAuthQuery } from \"@/registry/new-york/blocks/siwe-button/hooks/use-siwe-auth-query\"\nimport { useSessionKey } from \"@/registry/new-york/blocks/session-keys/hooks/use-session-key\"\n\ninterface OnboardingDialogProps {\n  steps?: {\n    connectWallet?: boolean\n    signWithEthereum?: boolean\n    createSessionKey?: boolean\n  }\n  open?: boolean\n  onOpenChange?: (open: boolean) => void\n  onComplete?: () => void\n  onStepComplete?: (step: string) => void\n  className?: ClassValue\n}\n\ninterface StepDefinition {\n  id: string\n  title: string\n  subtitle: string\n  component: React.ComponentType<{ className?: ClassValue }>\n  validate: () => boolean\n}\n\n/**\n * Onboarding Dialog\n * \n * A configurable multi-step onboarding dialog that guides users through:\n * - Wallet connection via ConnectWalletButton\n * - SIWE authentication via SiweButton\n * - Session key creation via SessionKeyButton\n * \n * Features:\n * - Visual progress indicator showing current step\n * - Auto-detection of completed steps\n * - Configurable step selection\n * - Automatic advancement when steps complete\n */\nexport function OnboardingDialog({\n  steps = {\n    connectWallet: true,\n    signWithEthereum: true,\n    createSessionKey: true,\n  },\n  open = false,\n  onOpenChange = () => {},\n  onComplete = () => {},\n  onStepComplete,\n  className,\n}: OnboardingDialogProps) {\n  const { isConnected } = useAccount()\n  const { data: authData } = useSiweAuthQuery()\n  const { data: sessionData } = useSessionKey()\n\n  const [currentStepIndex, setCurrentStepIndex] = useState(0)\n\n  // Check authentication and session status\n  const isAuthenticated = authData?.ok && authData?.user?.isAuthenticated\n  const hasActiveSession = !!sessionData\n\n  // Define all possible steps with their validation logic\n  const allStepDefinitions: StepDefinition[] = [\n    {\n      id: 'connectWallet',\n      title: 'Connect Wallet',\n      subtitle: 'Connect your wallet to get started',\n      component: ConnectWalletButton,\n      validate: () => isConnected,\n    },\n    {\n      id: 'signWithEthereum',\n      title: 'Sign In with Ethereum',\n      subtitle: 'Sign a message to authenticate your identity',\n      component: SiweButton,\n      validate: () => !!(isConnected && isAuthenticated),\n    },\n    {\n      id: 'createSessionKey',\n      title: 'Create Session Key',\n      subtitle: 'Create a session key for seamless transactions',\n      component: SessionKeyButton,\n      validate: () => !!(isConnected && hasActiveSession),\n    },\n  ]\n\n  // Filter to only enabled steps\n  const enabledSteps = allStepDefinitions.filter(step => steps[step.id as keyof typeof steps])\n\n  // Find the first incomplete step or stay at current\n  const findCurrentStep = () => {\n    for (let i = 0; i < enabledSteps.length; i++) {\n      if (!enabledSteps[i].validate()) {\n        return i\n      }\n    }\n    return enabledSteps.length - 1 // All complete, stay at last step\n  }\n\n  // Update current step when validation changes\n  useEffect(() => {\n    if (open) {\n      const newStepIndex = findCurrentStep()\n      if (newStepIndex !== currentStepIndex) {\n        setCurrentStepIndex(newStepIndex)\n      }\n    }\n  }, [isConnected, isAuthenticated, hasActiveSession, open])\n\n  // Check if all required steps are complete\n  const allStepsComplete = enabledSteps.every(step => step.validate())\n\n  // Handle completion\n  useEffect(() => {\n    if (allStepsComplete && open && enabledSteps.length > 0) {\n      // Small delay to show completion state\n      const timer = setTimeout(() => {\n        onComplete()\n        onOpenChange(false)\n      }, 500)\n      return () => clearTimeout(timer)\n    }\n  }, [allStepsComplete, open, onComplete, onOpenChange, enabledSteps.length])\n\n  // Handle step completion callback\n  useEffect(() => {\n    if (onStepComplete && enabledSteps[currentStepIndex]?.validate()) {\n      onStepComplete(enabledSteps[currentStepIndex].id)\n    }\n  }, [currentStepIndex, onStepComplete, enabledSteps])\n\n\n  // Don't render if no steps are enabled\n  if (enabledSteps.length === 0) {\n    return null\n  }\n\n  const currentStep = enabledSteps[currentStepIndex]\n  const StepComponent = currentStep?.component\n\n  return (\n    <Dialog open={open} onOpenChange={onOpenChange}>\n      <DialogContent className={cn(\"sm:max-w-md\", className)} showCloseButton={true}>\n        <div className=\"flex flex-col items-center space-y-6\">\n          {/* Progress Dots */}\n          <div className=\"flex justify-center space-x-2\">\n            {enabledSteps.map((step, index) => (\n              <div\n                key={step.id}\n                className={cn(\n                  \"h-2 w-2 rounded-full transition-colors\",\n                  step.validate()\n                    ? \"bg-green-500\"\n                    : index === currentStepIndex\n                      ? \"bg-primary\"\n                      : \"bg-muted\"\n                )}\n              />\n            ))}\n          </div>\n\n          {/* Step Title and Description */}\n          <div className=\"text-center space-y-2\">\n            <DialogTitle className=\"text-xl font-semibold\">{currentStep?.title}</DialogTitle>\n            <p className=\"text-muted-foreground\">{currentStep?.subtitle}</p>\n          </div>\n\n          {/* Current Step Component */}\n          <div className=\"w-full\">\n            {StepComponent && (\n              <StepComponent className=\"w-full\" />\n            )}\n          </div>\n\n        </div>\n      </DialogContent>\n    </Dialog>\n  )\n}",
      "type": "registry:component"
    },
    {
      "path": "registry/new-york/blocks/session-keys/session-key-button.tsx",
      "content": "\"use client\";\n\nimport { useAccount } from \"wagmi\";\nimport { Button } from \"@/registry/new-york/ui/button\";\nimport { DropdownMenuItem, DropdownMenuSeparator } from \"@/registry/new-york/ui/dropdown-menu\";\nimport { ConnectWalletButton } from \"@/registry/new-york/blocks/connect-wallet-button/connect-wallet-button\";\nimport { useSessionKey } from \"@/registry/new-york/blocks/session-keys/hooks/use-session-key\";\nimport { useCreateSessionKey } from \"@/registry/new-york/blocks/session-keys/hooks/use-create-session-key\";\nimport { useRevokeSessionKey } from \"@/registry/new-york/blocks/session-keys/hooks/use-revoke-session-key\";\nimport { cn } from \"@/lib/utils\";\nimport { type ClassValue } from \"clsx\";\n\ninterface SessionKeyButtonProps {\n    className?: ClassValue;\n}\n\n/**\n * Session Key Button\n * \n * A comprehensive session key management button that handles:\n * - Wallet connection via ConnectWalletButton integration\n * - Session key creation and validation\n * - Session key revocation with confirmation\n * - Loading states and error handling via toast notifications\n * \n * States:\n * - Not connected: Shows \"Connect Wallet\" button\n * - Connected but no session: Shows \"Create Session Key\" button  \n * - Session exists: Shows \"Session Active\" with dropdown containing revoke option\n */\nexport function SessionKeyButton({ className }: SessionKeyButtonProps) {\n    const { isConnected } = useAccount();\n    const { data: sessionData, isLoading: isSessionLoading } = useSessionKey();\n    const createSessionMutation = useCreateSessionKey();\n    const { revokeSession, isPending: isRevoking } = useRevokeSessionKey();\n\n    // Check if user has an active session\n    const hasActiveSession = !!sessionData;\n\n    // Handle session creation\n    const handleCreateSession = () => {\n        createSessionMutation.mutate();\n    };\n\n    // Handle session revocation\n    const handleRevokeSession = async (e: React.MouseEvent) => {\n        // Prevent dropdown from closing\n        e.preventDefault();\n        e.stopPropagation();\n        \n        if (sessionData?.session) {\n            await revokeSession(sessionData.session);\n        }\n    };\n\n    // Not connected: Use ConnectWalletButton\n    if (!isConnected) {\n        return <ConnectWalletButton className={className} />;\n    }\n\n    // Connected and has active session: Show session status with dropdown\n    if (isConnected && hasActiveSession && !isSessionLoading) {\n        return (\n            <ConnectWalletButton \n                className={className}\n                customDropdownItems={[\n                    <DropdownMenuSeparator key=\"sep\" />,\n                    <DropdownMenuItem \n                        key=\"session-info\" \n                        className=\"focus:bg-transparent cursor-auto\"\n                    >\n                        <div className=\"flex items-center justify-between w-full\">\n                            <span className=\"text-xs text-muted-foreground\">Session:</span>\n                            <div className=\"flex items-center space-x-2\">\n                                <div className=\"h-2 w-2 bg-green-500 rounded-full\" />\n                                <span className=\"text-xs text-green-600 dark:text-green-400\">Active</span>\n                            </div>\n                        </div>\n                    </DropdownMenuItem>,\n                    <DropdownMenuSeparator key=\"sep2\" />,\n                    <DropdownMenuItem \n                        key=\"revoke\" \n                        onClick={handleRevokeSession}\n                        disabled={isRevoking}\n                        className=\"text-destructive\"\n                    >\n                        {isRevoking ? (\n                            <>\n                                <Spinner className=\"mr-2 h-4 w-4 animate-spin\" />\n                                Revoking...\n                            </>\n                        ) : (\n                            <>\n                                <RevokeIcon className=\"mr-2 h-4 w-4\" />\n                                Revoke Session Key\n                            </>\n                        )}\n                    </DropdownMenuItem>\n                ]}\n            />\n        );\n    }\n\n    // Connected but no session OR loading: Show Create Session Key button\n    return (\n        <Button\n            onClick={handleCreateSession}\n            disabled={createSessionMutation.isPending || isSessionLoading}\n            className={cn(\"cursor-pointer group min-w-40\", className)}\n        >\n            {createSessionMutation.isPending ? (\n                <>\n                    <Spinner className=\"mr-2 h-4 w-4 animate-spin\" />\n                    Creating...\n                </>\n            ) : isSessionLoading ? (\n                <>\n                    <Spinner className=\"mr-2 h-4 w-4 animate-spin\" />\n                    Checking...\n                </>\n            ) : (\n                <>\n                    <KeyIcon className=\"mr-2 h-4 w-4\" />\n                    Create Session Key\n                </>\n            )}\n        </Button>\n    );\n}\n\nfunction Spinner({ className }: { className?: ClassValue }) {\n    return (\n        <svg\n            className={cn(\"animate-spin\", className)}\n            xmlns=\"http://www.w3.org/2000/svg\"\n            fill=\"none\"\n            viewBox=\"0 0 24 24\"\n        >\n            <circle\n                className=\"opacity-25\"\n                cx=\"12\"\n                cy=\"12\"\n                r=\"10\"\n                stroke=\"currentColor\"\n                strokeWidth=\"4\"\n            />\n            <path\n                className=\"opacity-75\"\n                fill=\"currentColor\"\n                d=\"m4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z\"\n            />\n        </svg>\n    );\n}\n\nfunction KeyIcon({ className }: { className?: ClassValue }) {\n    return (\n        <svg\n            className={cn(className)}\n            xmlns=\"http://www.w3.org/2000/svg\"\n            fill=\"none\"\n            viewBox=\"0 0 24 24\"\n            stroke=\"currentColor\"\n            strokeWidth=\"2\"\n        >\n            <path\n                strokeLinecap=\"round\"\n                strokeLinejoin=\"round\"\n                d=\"M15.75 5.25a3 3 0 013 3m3 0a6 6 0 01-7.029 5.912c-.563-.097-1.159.026-1.563.43L10.5 17.25H8.25v2.25H6v2.25H2.25v-2.818c0-.597.237-1.17.659-1.591l6.499-6.499c.404-.404.527-1 .43-1.563A6 6 0 1121.75 8.25z\"\n            />\n        </svg>\n    );\n}\n\nfunction RevokeIcon({ className }: { className?: ClassValue }) {\n    return (\n        <svg\n            className={cn(className)}\n            xmlns=\"http://www.w3.org/2000/svg\"\n            fill=\"none\"\n            viewBox=\"0 0 24 24\"\n            stroke=\"currentColor\"\n            strokeWidth=\"2\"\n        >\n            <path\n                strokeLinecap=\"round\"\n                strokeLinejoin=\"round\"\n                d=\"M6 18L18 6M6 6l12 12\"\n            />\n        </svg>\n    );\n}",
      "type": "registry:component"
    },
    {
      "path": "registry/new-york/blocks/session-keys/hooks/use-session-key.ts",
      "content": "\"use client\";\n\nimport { useQuery } from \"@tanstack/react-query\";\nimport { useAccount } from \"wagmi\";\nimport { useAbstractClient } from \"@abstract-foundation/agw-react\";\nimport { getStoredSession } from \"../lib/get-stored-session-key\";\n\n/**\n * Hook to retrieve and validate the stored Abstract session\n * @returns The session data with loading and error states\n */\nexport function useSessionKey() {\n    const { address } = useAccount();\n    const { data: abstractClient } = useAbstractClient();\n\n    return useQuery({\n        queryKey: [\"session-key\", address],\n        queryFn: async () => {\n            // These should never happen due to enabled condition, but adding for type safety\n            if (!abstractClient) {\n                throw new Error(\"No Abstract client found\");\n            }\n            if (!address) {\n                throw new Error(\"No wallet address found\");\n            }\n\n            return await getStoredSession(abstractClient, address);\n        },\n        enabled: !!address && !!abstractClient,\n        staleTime: 0, // Always refetch when invalidated\n        retry: (failureCount, error) => {\n            // Don't retry if it's a client/address error (these won't resolve with retry)\n            if (error.message.includes(\"No Abstract client\") || \n                error.message.includes(\"No wallet address\")) {\n                return false;\n            }\n            // Retry network/validation errors up to 2 times\n            return failureCount < 2;\n        },\n        retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 30000), // Exponential backoff\n    });\n}",
      "type": "registry:hook"
    },
    {
      "path": "registry/new-york/blocks/session-keys/hooks/use-create-session-key.ts",
      "content": "\"use client\";\n\nimport { useMutation, useQueryClient } from \"@tanstack/react-query\";\nimport { useAccount } from \"wagmi\";\nimport { useAbstractClient } from \"@abstract-foundation/agw-react\";\nimport { createAndStoreSession } from \"../lib/create-and-store-session-key\";\nimport { toast } from \"sonner\";\n\n/**\n * Hook to create and store Abstract sessions\n * @returns Mutation functions and state for creating sessions\n */\nexport function useCreateSessionKey() {\n    const { data: abstractClient } = useAbstractClient();\n    const { address } = useAccount();\n    const queryClient = useQueryClient();\n\n    const createSessionMutation = useMutation({\n        mutationFn: async () => {\n            if (!address) {\n                throw new Error(\"No wallet address found\");\n            }\n            if (!abstractClient) {\n                throw new Error(\"No Abstract client found\");\n            }\n\n            return createAndStoreSession(abstractClient, address);\n        },\n        onSuccess: async () => {\n            // Invalidate the session query to force a refetch\n            await queryClient.invalidateQueries({\n                queryKey: [\"session-key\", address],\n            });\n            \n            // Also refetch immediately to ensure state updates\n            await queryClient.refetchQueries({\n                queryKey: [\"session-key\", address],\n            });\n            \n            toast.success(\"Session key created successfully\");\n        },\n        onError: (error) => {\n            console.error(\"Failed to create session:\", error);\n            toast.error(\"Failed to create session key\");\n        },\n    });\n\n    return createSessionMutation;\n}",
      "type": "registry:hook"
    },
    {
      "path": "registry/new-york/blocks/session-keys/hooks/use-revoke-session-key.ts",
      "content": "\"use client\";\n\nimport { useRevokeSessions } from \"@abstract-foundation/agw-react\";\nimport { useAccount } from \"wagmi\";\nimport { useQueryClient } from \"@tanstack/react-query\";\nimport { toast } from \"sonner\";\nimport { clearStoredSession } from \"../lib/clear-stored-session-key\";\nimport type { SessionConfig } from \"@abstract-foundation/agw-client/sessions\";\n\n/**\n * Hook to revoke session keys with proper cleanup and error handling\n * @returns Mutation functions and state for revoking sessions\n */\nexport function useRevokeSessionKey() {\n    const { address } = useAccount();\n    const { revokeSessionsAsync, isPending, isError, error } = useRevokeSessions();\n    const queryClient = useQueryClient();\n\n    const revokeSession = async (session: SessionConfig) => {\n        if (!address) {\n            toast.error(\"No wallet address found\");\n            return;\n        }\n\n        try {\n            const result = await revokeSessionsAsync({\n                sessions: session\n            });\n\n            // The result might be undefined or have different structure; keep for potential future use\n\n            // Clear local storage after successful revocation\n            clearStoredSession(address);\n            \n            // Invalidate the session query to force a refetch\n            await queryClient.invalidateQueries({\n                queryKey: [\"session-key\", address],\n            });\n            \n            // Also refetch immediately to ensure state updates\n            await queryClient.refetchQueries({\n                queryKey: [\"session-key\", address],\n            });\n\n            toast.success(\"Session key revoked successfully\");\n        } catch (err) {\n            console.error(\"Failed to revoke session:\", err);\n            toast.error(\"Failed to revoke session key\");\n            throw err;\n        }\n    };\n\n    return {\n        revokeSession,\n        isPending,\n        isError,\n        error\n    };\n}",
      "type": "registry:hook"
    },
    {
      "path": "registry/new-york/blocks/session-keys/lib/get-stored-session-key.ts",
      "content": "import type { Address, Hex } from \"viem\";\nimport type { AbstractClient } from \"@abstract-foundation/agw-client\";\nimport { getSessionHash, type SessionConfig } from \"@abstract-foundation/agw-client/sessions\";\nimport { LOCAL_STORAGE_KEY_PREFIX, getEncryptionKey, decrypt } from \"./session-encryption-utils\";\nimport { validateSession } from \"./validate-session-key\";\nimport { CALL_POLICIES } from \"@/config/session-key-policies\";\n\nexport interface StoredSessionData {\n    session: SessionConfig;\n    privateKey: Hex;\n}\n\n/**\n * @function getStoredSession\n * @description Retrieves, decrypts, and validates a stored session for a wallet address\n * \n * This function performs several steps to securely retrieve and validate a stored session:\n * 1. Checks local storage for encrypted session data under the wallet address key\n * 2. Retrieves the encryption key for the wallet address\n * 3. Decrypts the session data using the encryption key\n * 4. Parses the decrypted data to obtain session information\n * 5. Validates that call policies match current configuration\n * 6. Validates the session by checking its status on-chain\n * \n * @param {AbstractClient} abstractClient - The Abstract client instance\n * @param {Address} userAddress - The wallet address to retrieve session for\n * @returns {Promise<StoredSessionData | null>} The session data if valid, null otherwise\n */\nexport const getStoredSession = async (\n    abstractClient: AbstractClient,\n    userAddress: Address\n): Promise<StoredSessionData | null> => {\n    if (!userAddress) return null;\n\n    const encryptedData = localStorage.getItem(\n        `${LOCAL_STORAGE_KEY_PREFIX}${userAddress}`\n    );\n\n    if (!encryptedData) return null;\n\n    try {\n        const key = await getEncryptionKey(userAddress);\n        const decryptedData = await decrypt(encryptedData, key);\n\n        const sessionData: StoredSessionData = JSON.parse(decryptedData, (_, value) => {\n            // Handle bigint deserialization\n            if (typeof value === \"string\" && /^\\d+$/.test(value)) {\n                try {\n                    return BigInt(value);\n                } catch {\n                    return value;\n                }\n            }\n            return value;\n        });\n\n        // Check if stored call policies match current configuration\n        const storedPoliciesJson = JSON.stringify(\n            sessionData.session.callPolicies,\n            (_, value) => typeof value === \"bigint\" ? value.toString() : value\n        );\n        const currentPoliciesJson = JSON.stringify(\n            CALL_POLICIES,\n            (_, value) => typeof value === \"bigint\" ? value.toString() : value\n        );\n\n        if (storedPoliciesJson !== currentPoliciesJson) {\n            // Call policies changed; invalidate stored session to force refresh\n            return null;\n        }\n\n        // Validate the session is still active on-chain\n        const sessionHash = getSessionHash(sessionData.session);\n        const isValid = await validateSession(\n            abstractClient,\n            userAddress,\n            sessionHash\n        );\n\n        return isValid ? sessionData : null;\n    } catch (error) {\n        console.error(\"Failed to retrieve stored session:\", error);\n        return null;\n    }\n};",
      "type": "registry:lib"
    },
    {
      "path": "registry/new-york/blocks/session-keys/lib/create-and-store-session-key.ts",
      "content": "import { generatePrivateKey, privateKeyToAccount } from \"viem/accounts\";\nimport { Address } from \"viem\";\nimport { SessionConfig } from \"@abstract-foundation/agw-client/sessions\";\nimport { LOCAL_STORAGE_KEY_PREFIX, getEncryptionKey, encrypt } from \"./session-encryption-utils\";\nimport { AbstractClient } from \"@abstract-foundation/agw-client\";\nimport { publicClient } from \"@/config/viem-clients\";\nimport { SESSION_KEY_CONFIG } from \"@/config/session-key-policies\";\n\n/**\n * @function createAndStoreSession\n * @description Creates a new Abstract Global Wallet session and stores it securely in local storage\n *\n * @param {Address} userAddress - The wallet address that will own the session\n *\n * @returns {Promise<Object|null>} A promise that resolves to:\n *   - The created session data object (containing `session` and `privateKey`) if successful\n *   - null if the userAddress is empty or invalid\n *\n * @throws {Error} Throws \"Session creation failed\" if there's an error during session creation\n */\nexport const createAndStoreSession = async (\n    abstractClient: AbstractClient,\n    userAddress: Address\n): Promise<{\n    session: SessionConfig;\n    privateKey: Address;\n} | null> => {\n    if (!userAddress) return null;\n\n    try {\n        const sessionPrivateKey = generatePrivateKey();\n        const sessionSigner = privateKeyToAccount(sessionPrivateKey);\n\n        const { session, transactionHash } = await abstractClient.createSession({\n            session: {\n                signer: sessionSigner.address,\n                ...SESSION_KEY_CONFIG,\n            },\n        });\n\n        if (transactionHash) {\n            await publicClient.waitForTransactionReceipt({\n                hash: transactionHash,\n            });\n        } else {\n            throw new Error(\"Transaction hash is null. Session was not created.\");\n        }\n\n        const sessionData = { session, privateKey: sessionPrivateKey };\n        const key = await getEncryptionKey(userAddress);\n        const encryptedData = await encrypt(\n            JSON.stringify(sessionData, (_, value) =>\n                typeof value === \"bigint\" ? value.toString() : value\n            ),\n            key\n        );\n\n        localStorage.setItem(\n            `${LOCAL_STORAGE_KEY_PREFIX}${userAddress}`,\n            encryptedData\n        );\n        return sessionData;\n    } catch (error) {\n        console.error(\"Failed to create session:\", error);\n        throw new Error(`Failed to create session key, ${error}`);\n    }\n};",
      "type": "registry:lib"
    },
    {
      "path": "registry/new-york/blocks/session-keys/lib/clear-stored-session-key.ts",
      "content": "import { LOCAL_STORAGE_KEY_PREFIX, ENCRYPTION_KEY_PREFIX } from \"./session-encryption-utils\";\nimport type { Address } from \"viem\";\n\n/**\n * @function clearStoredSession\n * @description Removes all stored session data for a specific wallet address from local storage\n *\n * This function cleans up both the encrypted session data and the encryption key\n * associated with a wallet address from the browser's local storage. It's typically\n * used when a session has expired, been revoked, or when the user wants to clear\n * their session data for privacy/security reasons.\n *\n * The function removes two items from local storage:\n * 1. The encrypted session data (stored with LOCAL_STORAGE_KEY_PREFIX + address)\n * 2. The encryption key used to encrypt/decrypt the session (stored with ENCRYPTION_KEY_PREFIX + address)\n *\n * @param {Address} userAddress - The wallet address whose session data should be cleared\n */\nexport const clearStoredSession = (userAddress: Address) => {\n    localStorage.removeItem(`${LOCAL_STORAGE_KEY_PREFIX}${userAddress}`);\n    localStorage.removeItem(`${ENCRYPTION_KEY_PREFIX}${userAddress}`);\n};",
      "type": "registry:lib"
    },
    {
      "path": "registry/new-york/blocks/session-keys/lib/session-encryption-utils.ts",
      "content": "import type { Address } from \"viem\";\n\n\n/**\n * @constant {string} LOCAL_STORAGE_KEY_PREFIX\n * @description Prefix used for storing encrypted session data in local storage\n *\n * The actual storage key is created by appending the user's wallet address to this prefix,\n * ensuring each wallet address has its own unique storage key.\n * The prefix includes the current NODE_ENV to separate data between environments.\n */\nexport const LOCAL_STORAGE_KEY_PREFIX = `abstract_session_${process.env.NODE_ENV || \"development\"}_`;\n\n/**\n * @constant {string} ENCRYPTION_KEY_PREFIX\n * @description Prefix used for storing encryption keys in local storage\n *\n * The actual storage key is created by appending the user's wallet address to this prefix,\n * ensuring each wallet address has its own unique encryption key stored separately from the\n * encrypted session data.\n * The prefix includes the current NODE_ENV to separate data between environments.\n */\nexport const ENCRYPTION_KEY_PREFIX = `encryption_key_${process.env.NODE_ENV || \"development\"}_`;\n\n\n/**\n * @function getEncryptionKey\n * @description Retrieves or generates an AES-GCM encryption key for a specific wallet address\n *\n * This function manages encryption keys used to secure session data in local storage.\n * It first checks if an encryption key already exists for the given wallet address.\n * If found, it imports and returns the existing key. Otherwise, it generates a new\n * 256-bit AES-GCM key, stores it in local storage, and returns it.\n *\n * The encryption keys are stored in local storage with a prefix (defined in constants.ts)\n * followed by the wallet address to ensure each wallet has its own unique encryption key.\n *\n * @param {Address} userAddress - The wallet address to get or generate an encryption key for\n *\n * @returns {Promise<CryptoKey>} A promise that resolves to a CryptoKey object that can be\n *                              used with the Web Crypto API for encryption and decryption\n */\nexport const getEncryptionKey = async (\n    userAddress: Address\n): Promise<CryptoKey> => {\n    const storedKey = localStorage.getItem(\n        `${ENCRYPTION_KEY_PREFIX}${userAddress}`\n    );\n\n    if (storedKey) {\n        return crypto.subtle.importKey(\n            \"raw\",\n            Buffer.from(storedKey, \"hex\"),\n            { name: \"AES-GCM\" },\n            false,\n            [\"encrypt\", \"decrypt\"]\n        );\n    }\n\n    const key = await crypto.subtle.generateKey(\n        { name: \"AES-GCM\", length: 256 },\n        true,\n        [\"encrypt\", \"decrypt\"]\n    );\n\n    const exportedKey = await crypto.subtle.exportKey(\"raw\", key);\n    localStorage.setItem(\n        `${ENCRYPTION_KEY_PREFIX}${userAddress}`,\n        Buffer.from(exportedKey).toString(\"hex\")\n    );\n\n    return key;\n};\n\n/**\n * @function encrypt\n * @description Encrypts data using AES-GCM encryption with a provided CryptoKey\n *\n * This function uses the Web Crypto API to encrypt session data for secure storage\n * in the browser's local storage. It generates a random initialization vector (IV)\n * for each encryption operation to ensure security. The encrypted data and IV are\n * both stored in the returned JSON string.\n *\n * @param {string} data - The data to encrypt, typically a stringified JSON object\n *                        containing session information and private keys\n * @param {CryptoKey} key - The AES-GCM encryption key to use\n *\n * @returns {Promise<string>} A promise that resolves to a JSON string containing\n *                           the encrypted data and the initialization vector (IV)\n *                           both encoded as hex strings\n */\nexport const encrypt = async (\n    data: string,\n    key: CryptoKey\n): Promise<string> => {\n    const iv = crypto.getRandomValues(new Uint8Array(12));\n    const encrypted = await crypto.subtle.encrypt(\n        { name: \"AES-GCM\", iv },\n        key,\n        new TextEncoder().encode(data)\n    );\n\n    return JSON.stringify({\n        iv: Buffer.from(iv).toString(\"hex\"),\n        data: Buffer.from(encrypted).toString(\"hex\"),\n    });\n};\n\n/**\n * @function decrypt\n * @description Decrypts data that was encrypted using the encrypt function\n *\n * This function uses the Web Crypto API to decrypt session data that was previously\n * encrypted with the corresponding encrypt function. It expects the input to be a\n * JSON string containing both the encrypted data and the initialization vector (IV)\n * that was used for encryption.\n *\n * @param {string} encryptedData - The encrypted data JSON string containing both the\n *                                encrypted data and the initialization vector (IV)\n *                                as hex strings\n * @param {CryptoKey} key - The AES-GCM decryption key to use (same key used for encryption)\n *\n * @returns {Promise<string>} A promise that resolves to the decrypted data as a string\n *\n * @throws Will throw an error if decryption fails, which may happen if the encryption\n *        key is incorrect or the data has been tampered with\n */\nexport const decrypt = async (\n    encryptedData: string,\n    key: CryptoKey\n): Promise<string> => {\n    const { iv, data } = JSON.parse(encryptedData);\n    const decrypted = await crypto.subtle.decrypt(\n        { name: \"AES-GCM\", iv: Buffer.from(iv, \"hex\") },\n        key,\n        Buffer.from(data, \"hex\")\n    );\n\n    return new TextDecoder().decode(decrypted);\n};",
      "type": "registry:lib"
    },
    {
      "path": "registry/new-york/blocks/session-keys/lib/validate-session-key.ts",
      "content": "import { abstractTestnet } from \"viem/chains\";\nimport type { AbstractClient } from \"@abstract-foundation/agw-client\";\nimport type { Address } from \"viem\";\nimport { chain } from \"@/config/chain\";\nimport { clearStoredSession } from \"./clear-stored-session-key\";\n\n/**\n * @function validateSession\n * @description Checks if a session is valid by querying the session validator contract\n\nThis function verifies whether a session is still valid (active) by calling the\nsessionStatus function on the Abstract Global Wallet session validator contract.\nIf the session is found to be invalid (expired, closed, or non-existent), it\nautomatically cleans up the invalid session data.\n\nThe validation is performed on-chain by checking the status of the session hash\nfor the given wallet address. The status is mapped to the SessionStatus enum,\nwhere Active (1) indicates a valid session.\n * @param {Address} address - The wallet address that owns the session\n * @param {string} sessionHash - The hash of the session to validate\n * @returns {Promise<boolean>} A promise that resolves to a boolean indicating whether\nthe session is valid (true) or not (false)\n */\nexport const validateSession = async (\n    abstractClient: AbstractClient,\n    address: Address,\n    sessionHash: `0x${string}`\n): Promise<boolean> => {\n    try {\n        const status = await abstractClient.getSessionStatus(sessionHash);\n\n        // On Abstract testnet, any session is allowed, so we skip the check\n        // However, on mainnet, we need to check if the session is both whitelisted and active.\n        const isValid =\n            status === SessionStatus.Active ||\n            (chain === abstractTestnet && status === SessionStatus.NotInitialized);\n\n        if (!isValid) {\n            clearStoredSession(address);\n        }\n\n        return isValid;\n    } catch (error) {\n        console.error(\"Failed to validate session:\", error);\n        return false;\n    }\n};\n\n/**\n * @enum {number} SessionStatus\n * @description Represents the possible statuses of an Abstract Global Wallet session\n *\n * This enum maps to the SessionKeyPolicyRegistry.Status values.\n * It's used to determine if a session is valid and can be used to submit transactions on behalf of the wallet.\n */\nenum SessionStatus {\n    /**\n     * Session has not been initialized or does not exist\n     */\n    NotInitialized = 0,\n\n    /**\n     * Session is active and can be used to submit transactions\n     */\n    Active = 1,\n\n    /**\n     * Session has been manually closed/revoked by the wallet owner\n     */\n    Closed = 2,\n\n    /**\n     * Session has expired (exceeded its expiresAt timestamp)\n     */\n    Expired = 3,\n}\n\nexport default SessionStatus;",
      "type": "registry:lib"
    },
    {
      "path": "config/session-key-policies.ts",
      "content": "/**\n * IMPORTANT: https://docs.abs.xyz/abstract-global-wallet/session-keys/going-to-production\n * Your session key config requires approval to operate on Abstract mainnet via whitelist.\n */\n\nimport {\n    LimitType,\n    type SessionConfig,\n} from \"@abstract-foundation/agw-client/sessions\";\nimport { parseEther, toFunctionSelector } from \"viem\";\n\n/**\n * What call policies you wish to allow for the session key\n * Learn more: https://docs.abs.xyz/abstract-global-wallet/agw-client/session-keys/createSession#param-call-policies\n */\nexport const CALL_POLICIES = [\n    {\n        target: \"0xC4822AbB9F05646A9Ce44EFa6dDcda0Bf45595AA\" as `0x${string}`, // Contract address\n        selector: toFunctionSelector(\"mint(address,uint256)\"), // Allowed function\n        // Gas parameters\n        valueLimit: {\n            limitType: LimitType.Unlimited,\n            limit: BigInt(0),\n            period: BigInt(0),\n        },\n        maxValuePerUse: BigInt(0),\n        constraints: [],\n    }\n];\n\n/**\n * What transfer policies you wish to allow for the session key\n * Learn more: https://docs.abs.xyz/abstract-global-wallet/agw-client/session-keys/createSession#param-transfer-policies\n */\nexport const TRANSFER_POLICIES = [\n    // ... Your transfer policies here\n]\n\nexport const SESSION_KEY_CONFIG: Omit<SessionConfig, \"signer\"> = {\n    expiresAt: BigInt(Math.floor(Date.now() / 1000) + 60 * 60 * 24 * 30), // 30 days from now\n    feeLimit: {\n        limitType: LimitType.Lifetime,\n        limit: parseEther(\"1\"), // 1 ETH lifetime gas limit\n        period: BigInt(0),\n    },\n    callPolicies: CALL_POLICIES,\n    transferPolicies: [],\n};",
      "type": "registry:lib",
      "target": "config/session-key-policies.ts"
    },
    {
      "path": "config/viem-clients.ts",
      "content": "import { createPublicClient, createWalletClient, http } from \"viem\";\nimport { eip712WalletActions, publicActionsL2 } from \"viem/zksync\";\nimport { chain } from \"./chain\";\n\n/**\n * Viem specific extensions for ZK Stack chains (i.e., Abstract)\n * Learn more: https://viem.sh/zksync/\n */\n\n// Global Viem public client instance\nexport const publicClient = createPublicClient({\n  chain: chain,\n  transport: http(),\n}).extend(publicActionsL2());\n\n// Global Viem wallet client instance\nexport const walletClient = createWalletClient({\n  chain: chain,\n  transport: http(),\n}).extend(eip712WalletActions());\n",
      "type": "registry:lib",
      "target": "config/viem-clients.ts"
    },
    {
      "path": "registry/new-york/blocks/connect-wallet-button/connect-wallet-button.tsx",
      "content": "\"use client\"\n\nimport { useLoginWithAbstract } from \"@abstract-foundation/agw-react\"\nimport { Button } from \"@/registry/new-york/ui/button\"\nimport { useAccount, useBalance } from \"wagmi\"\nimport { cn } from \"@/lib/utils\"\nimport { type ClassValue } from \"clsx\"\nimport {\n  DropdownMenu,\n  DropdownMenuContent,\n  DropdownMenuItem,\n  DropdownMenuSeparator,\n  DropdownMenuTrigger,\n} from \"@/registry/new-york/ui/dropdown-menu\"\nimport { useState } from \"react\"\n\ninterface ConnectWalletButtonProps {\n  className?: ClassValue\n  customDropdownItems?: React.ReactNode[]\n}\n\n/**\n * Connect Wallet Button for Abstract Global Wallet\n * \n * A comprehensive wallet connection component that handles:\n * - Wallet connection/disconnection via Abstract Global Wallet\n * - Loading states during connection\n * - Balance display with wallet and Abstract logos\n * - Dropdown menu with address copy functionality\n */\nexport function ConnectWalletButton({ className, customDropdownItems }: ConnectWalletButtonProps) {\n  // Wagmi hooks for wallet state and balance\n  const { isConnected, status, address } = useAccount()\n  const { data: balance, isLoading: isBalanceLoading } = useBalance({ address })\n\n  // Abstract Global Wallet authentication\n  const { login, logout } = useLoginWithAbstract()\n\n  // Local state for connection status and copy feedback\n  const isConnecting = status === 'connecting' || status === 'reconnecting'\n  const [copied, setCopied] = useState(false)\n\n  /**\n   * Copy wallet address to clipboard with visual feedback\n   */\n  const copyAddress = async () => {\n    if (address) {\n      await navigator.clipboard.writeText(address)\n      setCopied(true)\n      setTimeout(() => setCopied(false), 2000)\n    }\n  }\n\n  // Loading state: Show connecting button with spinning logo\n  if (isConnecting) {\n    return (\n      <Button\n        disabled\n        className={cn(\"cursor-pointer group min-w-40\", className)}\n      >\n        Connecting...\n        <AbstractLogo className=\"ml-2 animate-spin\" />\n      </Button>\n    )\n  }\n\n  // Disconnected state: Show connect button with hover animation\n  if (!isConnected) {\n    return (\n      <Button\n        onClick={login}\n        className={cn(\"cursor-pointer group min-w-40\", className)}\n      >\n        Connect Wallet\n        <AbstractLogo className=\"ml-2 group-hover:animate-spin transition-transform\" />\n      </Button>\n    )\n  }\n\n  // Connected but loading balance: Show loading state\n  if (isConnected && isBalanceLoading) {\n    return (\n      <Button\n        disabled\n        className={cn(\"cursor-pointer group min-w-40 px-3\", className)}\n      >\n        <WalletIcon className=\"mr-1 h-4 w-4\" />\n        Loading...\n        <AbstractLogo className=\"ml-1 h-4 w-4 animate-spin\" />\n      </Button>\n    )\n  }\n\n  // Format the balance for display (4 decimal places)\n  const formattedBalance = balance\n    ? `${parseFloat(balance.formatted).toFixed(4)} ${balance.symbol}`\n    : '0.0000 ETH'\n\n  // Connected state: Show balance with dropdown menu\n  return (\n    <DropdownMenu>\n      <DropdownMenuTrigger asChild>\n        <Button\n          className={cn(\"cursor-pointer group min-w-40 px-3\", className)}\n        >\n          <WalletIcon className=\"mr-1 h-4 w-4\" />\n          {formattedBalance}\n          <AbstractLogo className=\"ml-1 h-4 w-4\" />\n        </Button>\n      </DropdownMenuTrigger>\n      <DropdownMenuContent align=\"center\" side=\"bottom\" className=\"w-56\">\n        {/* Address display with copy functionality */}\n        <DropdownMenuItem className=\"focus:bg-transparent cursor-auto\">\n          <div className=\"flex items-center justify-between w-full\">\n            <span className=\"text-xs text-muted-foreground font-mono\">\n              {address ? `${address.slice(0, 6)}...${address.slice(-4)}` : 'Connected'}\n            </span>\n            {address && (\n              <Button\n                variant=\"ghost\"\n                size=\"sm\"\n                className=\"h-6 w-6 p-0 hover:bg-accent\"\n                onClick={(e) => {\n                  // Prevent dropdown from closing when copying\n                  e.preventDefault()\n                  e.stopPropagation()\n                  copyAddress()\n                }}\n              >\n                {copied ? (\n                  <CheckIcon className=\"h-2.5 w-2.5\" />\n                ) : (\n                  <CopyIcon className=\"h-2.5 w-2.5\" />\n                )}\n              </Button>\n            )}\n          </div>\n        </DropdownMenuItem>\n        {/* Custom dropdown items or default disconnect */}\n        {customDropdownItems ? (\n          customDropdownItems\n        ) : (\n          <>\n            <DropdownMenuSeparator />\n            <DropdownMenuItem onClick={logout} className=\"text-destructive\">\n              Disconnect\n            </DropdownMenuItem>\n          </>\n        )}\n      </DropdownMenuContent>\n    </DropdownMenu>\n  )\n}\n\nfunction WalletIcon({ className }: { className?: ClassValue }) {\n  return (\n    <svg\n      width=\"16\"\n      height=\"16\"\n      viewBox=\"0 0 640 640\"\n      xmlns=\"http://www.w3.org/2000/svg\"\n      className={cn(className)}\n    >\n      <path\n        d=\"M128 96C92.7 96 64 124.7 64 160L64 448C64 483.3 92.7 512 128 512L512 512C547.3 512 576 483.3 576 448L576 256C576 220.7 547.3 192 512 192L136 192C122.7 192 112 181.3 112 168C112 154.7 122.7 144 136 144L520 144C533.3 144 544 133.3 544 120C544 106.7 533.3 96 520 96L128 96zM480 320C497.7 320 512 334.3 512 352C512 369.7 497.7 384 480 384C462.3 384 448 369.7 448 352C448 334.3 462.3 320 480 320z\"\n        fill=\"currentColor\"\n      />\n    </svg>\n  )\n}\nfunction CopyIcon({ className }: { className?: ClassValue }) {\n  return (\n    <svg\n      width=\"16\"\n      height=\"16\"\n      viewBox=\"0 0 24 24\"\n      fill=\"none\"\n      stroke=\"currentColor\"\n      strokeWidth=\"2\"\n      strokeLinecap=\"round\"\n      strokeLinejoin=\"round\"\n      className={cn(className)}\n    >\n      <rect width=\"14\" height=\"14\" x=\"8\" y=\"8\" rx=\"2\" ry=\"2\" />\n      <path d=\"M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2\" />\n    </svg>\n  )\n}\n\nfunction CheckIcon({ className }: { className?: ClassValue }) {\n  return (\n    <svg\n      width=\"16\"\n      height=\"16\"\n      viewBox=\"0 0 24 24\"\n      fill=\"none\"\n      stroke=\"currentColor\"\n      strokeWidth=\"2\"\n      strokeLinecap=\"round\"\n      strokeLinejoin=\"round\"\n      className={cn(className)}\n    >\n      <path d=\"M20 6L9 17l-5-5\" />\n    </svg>\n  )\n}\n\nfunction AbstractLogo({ className }: { className?: ClassValue }) {\n  return (\n    <svg\n      width=\"20\"\n      height=\"18\"\n      viewBox=\"0 0 52 47\"\n      fill=\"none\"\n      xmlns=\"http://www.w3.org/2000/svg\"\n      className={cn(className)}\n    >\n      <path d=\"M33.7221 31.0658L43.997 41.3463L39.1759 46.17L28.901 35.8895C28.0201 35.0081 26.8589 34.5273 25.6095 34.5273C24.3602 34.5273 23.199 35.0081 22.3181 35.8895L12.0432 46.17L7.22205 41.3463L17.4969 31.0658H33.7141H33.7221Z\" fill=\"currentColor\" />\n      <path d=\"M35.4359 28.101L49.4668 31.8591L51.2287 25.2645L37.1978 21.5065C35.9965 21.186 34.9954 20.4167 34.3708 19.335C33.7461 18.2613 33.586 17.0033 33.9063 15.8013L37.6623 1.76283L31.0713 0L27.3153 14.0385L35.4279 28.093L35.4359 28.101Z\" fill=\"currentColor\" />\n      <path d=\"M15.7912 28.101L1.76028 31.8591L-0.00158691 25.2645L14.0293 21.5065C15.2306 21.186 16.2316 20.4167 16.8563 19.335C17.4809 18.2613 17.6411 17.0033 17.3208 15.8013L13.5648 1.76283L20.1558 0L23.9118 14.0385L15.7992 28.093L15.7912 28.101Z\" fill=\"currentColor\" />\n    </svg>\n  )\n}",
      "type": "registry:component"
    }
  ]
}